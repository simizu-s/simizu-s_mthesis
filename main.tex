\documentclass[11pt]{ist-thesis}
% \pagestyle{bachelorthesis}  % 卒論
%\pagestyle{ebachelorthesis}  % Graduation Thesis
\pagestyle{masterthesis}  % 修論（目安;38ページ以上）
% \pagestyle{emasterthesis}  % Master Thesis
%\pagestyle{draft}  % 未完成ドラフト
%\pagestyle{edraft}  % Draft

\usepackage{listings}
\usepackage{xcolor}
\usepackage[dvipdfmx]{graphicx}
\usepackage{subcaption}
\usepackage{multirow}
\usepackage{otf}
\usepackage{makecell}

% 言語ごとのスタイル設定
\lstset{
    language=Java,                  % 言語指定
    basicstyle=\small\ttfamily,     % 基本フォント
    % keywordstyle=\color{blue},      % 予約語の色
    commentstyle=\color{green!60!black}, % コメントの色
    % stringstyle=\color{orange},     % 文字列の色
    numbers=left,                   % 行番号を左に表示
    numberstyle=\tiny\color{gray},  % 行番号のスタイル
    frame=lines,                  % 枠線
    breaklines=true,                % 長い行の自動折り返し
    captionpos=b                    % キャプションを下に配置
}

% キャプションの名前を「Listing」から「ソースコード」に変更
\renewcommand{\lstlistingname}{ソースコード}
\definecolor{highlightorange}{RGB}{255, 200, 100} % 少し薄めのオレンジを指定

\usepackage[table]{xcolor} % 表の色付けに必要
\definecolor{high_val}{HTML}{FFCC99}  % 70%以上（濃いめ）
\definecolor{mid_val}{HTML}{FFE5CC}   % 60%以上（薄め）

\title{コードクローン検出の後処理としての統一的ラベリング手法}
\author{清水 ささら}
\supervisor{肥後 芳樹 教授}
%\supervisor{Professor Yoshiki Higo}
\deadline{令和8年2月2日} % 正規の提出期日
%\deadline{February Xth, XXXX}

\begin{document}

\titlepage

% タイトル中に改行が含まれる場合は，改行を取り除いたタイトルを再定義
\title{コードクローン検出の後処理としての統一的ラベリング手法}

\abstract{
コードクローンはソースコード中に存在する，一致または類似するコード片であり，バグの修正漏れを引き起こす原因となる．
種々のコードクローン検出ツールが提案されているが，それぞれが独自の手法を用いて検出を行っている．
コードクローンは類似度に応じてType1，Type2，Type3，Type4の4種類に分類されるが，これらの定義は必ずしも厳密ではなく，
特にType3とType4の境界は曖昧である．
その結果，ある検出ツールではType3として検出されたコードクローンが，別の検出ツールではType4として扱われるといった不整合が生じる．
また，多くのコードクローン検出ツールは検出のみを行い，どのTypeのクローンであるかのラベル付けを行わない．
このことから，複数のツールの検出結果を単一のデータセットとして扱えない問題が発生する．

本研究では，これらの問題を解決するために，コードクローン検出後の後処理として統一的なラベリング手法を提案する．
提案手法を用いることで，使用するコードクローン検出ツールに依存することなく，検出されたコードクローンに対して一貫した基準に基づくラベリングが可能となる．
近年，ソフトウェア工学分野ではコードクローン情報を大規模言語モデル（LLM）の学習データとして利用する研究が増加しており，
本研究で提案するラベリング手法は，高品質にラベル付けされたコードクローンデータの構築にも寄与する．
提案手法の有効性を評価するため，広く利用されているコードクローンデータセットであるBigCloneBenchに含まれるコードクローンを対象に再ラベリングを行った．
そして，BigCloneBenchにおける既存のラベリングと提案手法によるラベリングについて被験者実験を実施し，どちらがコードクローンの定義により適合しているかを比較・分析した．

評価実験の結果，BigCloneBenchでType4と判定されていたクローンペアを提案手法がType3と分類したケースでは，
提案手法の方が人間の感覚に近いことが確認された．
しかし，その逆のケースでは既存のラベルの方が支持される傾向にあり，
提案手法の判定ルールをより実態に合わせて細かく調整していく必要性が示唆された．
また，被験者によって判断が分かれた事実は，クローンの境界が曖昧さを示しており，
本研究が目的とする一貫したラベリング基準を確立することの重要性を再確認した．
}

\keyword{
  \hspace{7mm} コードクローン\\
  \hspace{7mm} BigCloneBench\\
  \hspace{7mm} 抽象構文木\\
}

% 目次を出力
\toc

% 本文開始
% \section{1章タイトル}
% 1章本文
% \subsection{1.1節タイトル}
% 1.1節本文
% \subsubsection{1.1.1項タイトル}
% 1.1.1項本文

\section{はじめに}
コードクローンとは，プログラムテキスト中の一致または類似するコード片である~\cite{Inoue2001}.
コードクローンにバグが含まれているとバグの修正漏れを引き起こす原因になり，ソースコードの保守性が低下する要因の一つとなる~\cite{Roy2007}．
コードクローンは，構文的な類似度に基づいてType1，Type2，Type3，Type4の4種類に分類される~\cite{Roy2009}．
ソースコードの規模が大きくなると，手動でコードクローンを管理することは困難となる．
そのため，コードクローンを自動で検出するツールの研究が行われている．

現状では，ソースコード中のコードクローン検出は，単一のツールを用いて行われる．
様々なコードクローン検出ツールが存在するが，それらは，検出する際に用いる中間表現や計算アルゴリズムが異なる．
例えば，NiCad~\cite{Nicad}は行単位での検出，
CCFinder~\cite{KamiyaTSE2002}，NIL~\cite{NIL}は字句単位での検出を行う．
単一のコードクローン検出ツールを用いた検出では，ソースコードから検出できるコードクローンに偏りが生じる．
この課題解決のため，一つのソースコードに対し
複数のコードクローン検出ツールを実行することが考えられる．
複数のツールを利用することで可能な限りコードクローンを検出する．
しかし，各ツールは，分類の基準が異なるため，コードクローンとして検出されたコードに対して異なるラベリングを行う場合がある．
また，コードクローンの検出は行うものの，分類は行わないツールも存在する．
ラベリング結果が異なることや，ラベリングが行われないことは，複数ツールから得られたクローン検出結果を用いて
大規模なコードクローンのデータセットを作成する際に，単一のデータセットとして統合ができないという問題が発生する．

この問題解決のため，本研究では，コードクローン検出後の後処理として統一的なラベリング手法を提案する．
提案手法を用いることで，複数の検出ツールから検出されたコードクローンに対し，統一されたラベリングを行うことができる．
統一的なラベリングが行われたコードクローンは単一のデータセットに統合が可能となり，コードクローンデータを他の研究や開発に利用しやすくなる．

また，既存のコードクローンデータセットであるBigCloneBench~\cite{BigCloneBench}は最大規模のデータセットであり，
Type3およびType4の分類に行単位の類似度を用いているが，こうした類似度に基づく分類は解析の単位粒度に結果が左右されるという課題がある．
したがって，本研究では類似度という数値的な判定ではなく，プログラムの論理的な構造を直接反映する
抽象構文木の構造的特徴に基づいた新たなType分類の定義を導入する．
これにより，解析の単位粒度に左右されない，一貫性のある客観的な分類を実現する．

本研究では，提案手法を評価するために被験者実験を行った．
被験者実験では，BigCloneBench~\cite{BigCloneBench}に含まれるクローンペアを対象とし，
BigCloneBenchによる分類と，提案手法による分類のどちらが人間の感覚に近いかを調査した．
その結果，BigCloneBenchでType4に分類され，提案手法でType3と分類されたクローンペアについては，
提案手法による分類の方が，人間の感覚に近いことがわかり，
BigCloneBenchの分類が人間の直感と反するケースが存在することが確認できた．
一方，BigCloneBenchでType3に分類され，提案手法でType4と分類されたクローンペアについては，
BigCloneBenchの分類の方が，人間の感覚に近いことがわかり，分類の定義について修正を行う必要性が示唆された．
定義の修正を行うことで，人間の感覚により近い分類が可能となる．
また，被験者ごとの傾向から，Type3およびType4のコードクローンの分類の定義の曖昧さが示唆され，
本研究の目的である，統一的なラベリング手法の必要性が改めて確認された．

以降，2章では，本研究で用いる技術について述べる．
3章では，本研究の動機について述べる．
4章では，提案手法の詳細について述べる．
5章では，評価実験の詳細について述べ，6章でその結果と考察を述べる．
7章では，妥当性の脅威を述べ，8章では，まとめと今後の課題について述べる．


% \textcolor{blue}{




\section{準備}

% 本章では，コードクローン，コードクローン検出ツール，コードクローンのデータセット，抽象構文木について述べる，

\subsection{コードクローン}
% Type分類について
コードクローンとは，プログラムテキスト中の一致または類似するコード片である~\cite{Inoue2001}. 
コピーとペーストによるプログラミングや，意図的に同一の処理を繰り返して書くことにより発生する．
複数のコードクローンがソフトウェアプログラム中に存在した場合，あるコードクローン上にバグが見つかると，
他のコードクローンにもバグが含まれる可能性が出てくる．
そのため，開発者は，全てのコードクローンを追跡する必要がある．
これは，バグの修正漏れを引き起こす原因になり，ソースコードの保守性が低下する要因の一つとなる~\cite{Roy2007}．
また，互いにクローン関係であるソースコード片のペアを，クローンペアと呼ぶ．

一般にコードクローンは，構文的な類似度に基づき，以下の4種類に分類される~\cite{Roy2009}．

\begin{description}
    \item[Type1] 改行，コメント，空白を除いて一致するコードクローン
    \item[Type2] Type1に加えて，リテラル，識別子，型の違いを除いて一致するコードクローン
    \item[Type3] Type2に加えて，文の挿入，削除，変更を除いて一致するコードクローン
    \item[Type4] 構文は異なるが同じ機能を提供するコードクローン
\end{description}

上記のType3，Type4の境界は曖昧であるため，コードクローン検出ツールによって分類の基準が異なる．


\subsection{コードクローン検出ツール}

ソースコードの規模が大きくなると，ソースコード中のコードクローンの量も増加するため，手動でコードクローンを管理することは困難となる．
そのため，ソースコード中から自動的にコードクローンを検出するツールが研究されている
~\cite{StoneDetector,iClones,Jiang2007,KamiyaTSE2002,GroupDroid,NIL,Nicad,SourcererCC,YandCOMPSAC2018,CCGraph}．

% 1. 行単位および字句単位の手法
行単位で解析を行う手法として代表的なNiCad~\cite{Nicad}は，ソースコードの整形と正規化を行い，
行の一致率を見ることでコードクローンの検出を行う．
検出だけでなく．Type1からType3までのラベリングを行う．

字句単位で解析を行う手法は，ソースコードをトークン列に変換して比較を行う．
CCFinder~\cite{KamiyaTSE2002}やiClones~\cite{iClones}，LVMapper~\cite{LVMapper}は
大規模なプロジェクトから高速にクローンを抽出することに長けているが，
出力結果はコードクローンがどこに含まれるかの情報のみであり，どのTypeに分類されるかのラベリングは行われない．
一方で，NIL~\cite{NIL}やSourcererCC~\cite{SourcererCC}は，
字句単位の類似度計算に基づいたラベリングを行う．

% 2. 構文構造（AST）単位の手法
2.4節で述べる抽象構文木を利用する手法として，Deckard~\cite{Jiang2007}が挙げられる．
% ソースコードを構文解析して木構造を構築し，その構造的類似度を比較する．
% Deckard~\cite{Jiang2007}は，抽象構文木のサブツリーを多次元ベクトルへと変換し，LSH(Locality Sensitive Hashing)
% を用いることで，文の挿入・削除を伴うType3クローンを効率的に検出する．
Deckardはクローンの検出だけでなく，分類に応じたラベリングも行う．

% 3. グラフ単位の手法
グラフ形式の中間表現を用いる手法は，主にType4クローンの検出を目的とする．
Yangらの手法~\cite{YandCOMPSAC2018}，StoneDetector~\cite{StoneDetector}，GroupDroid~\cite{GroupDroid}，CCGraph~\cite{CCGraph}などがこれに該当する．
これらの手法は，グラフの構造的一致を判定するため，記述形式に依存しない高度な解析が可能である．
一方で，グラフの同型判定アルゴリズムは高い計算コストを伴う点が課題となる．
また，これらのツールは，機能の等価性に焦点を当てているため，
Type1からType3への詳細なラベリングまでは行わない．

% まとめと本研究の立ち位置
% 以上の通り、多くの検出ツール（特に字句ベースやグラフベース）は、クローンの抽出能力には優れているものの、検出結果に対して標準的なラベル（Type-1〜4）を付与する機能を持っていない。このことが、異なるツール間での結果の統合や、機械学習用の高品質なデータセット構築を困難にする要因となっている。本研究が提案する**「後処理としての統一的ラベリング手法」**は、これら既存ツールの出力結果を入力とし、一貫した基準でラベルを再付与することで、既存のクローン情報の利用価値を向上させるものである。

それぞれのツールについて表~\ref{tab:tool_comparison}に示す．
表~\ref{tab:tool_comparison}では，コードクローン検出のための手法と，ツールがコードクローンを検出する際，Type分類のラベルを出力するか否かを示す．
% 2.1節の定義において，Type3とType4の境界は曖昧である．
コードクローン検出ツールはそれぞれ独自の中間表現(抽象構文木，グラフ，トークン列など)や類似度計算アルゴリズムを用いているため，
同じソースコードからコードクローンを検出する場合でも検出されるコードクローンが異なったり，同じ箇所がコードクローンとして検出された場合でもその分類が異なったりする．
また，コードクローン検出ツールには，検出のみを行い，分類を行わないツールも存在する．


\begin{table}[!b]
\centering
\caption{既存のコードクローン検出ツール}
\label{tab:tool_comparison}
\begin{tabular}{llc}\hline
手法 & ツール名/著者名 & ラベルの有無 \\ \hline
行単位での検出 &  Nicad~\cite{Nicad} & あり \\ \hline
\multirow{5}{*}{字句単位での検出} & NIL~\cite{NIL} & あり \\ 
 & CCFinder~\cite{KamiyaTSE2002} & なし \\
 & iClones~\cite{iClones} & なし \\
 & SoucererCC~\cite{SourcererCC} & あり \\
 & LVMapper~\cite{LVMapper} & なし \\ \hline
\multirow{1}{*}{抽象構文木を用いた検出} & Deckard~\cite{Jiang2007} & あり \\ \hline
\multirow{4}{*}{グラフを用いた検出} & Yang~\cite{YandCOMPSAC2018} & なし \\
 & StoneDetector~\cite{StoneDetector} & なし \\
 & GroupDroid~\cite{GroupDroid} & なし \\ 
 & CCGraph~\cite{CCGraph} & なし \\ \hline
\end{tabular}
\end{table}

表~\ref{tab:tool_comparison}に示したコードクローン検出ツールの他に，機械学習を用いたコードクローン検出手法も存在する~\cite{BuiICSE2021,Feng2020,Li2025,LiICSME2017,Saini2018,ZhangICSE2019,Zhao2018}．

% 機械学習ツール~\cite{BuiICSE2021,Li2025,LiICSME2017,Saini2018,ZhangICSE2019,Zhao2018}
% 学習にBigCloneBench~\cite{Li2025,LiICSME2017,ZhangICSE2019}
% 評価~\cite{Zhao2018,Saini2018,BuiICSE2021}
% ,Feng2020 CodeBERT

\subsection{コードクローンのデータセット}

既存のコードクローンデータセットを表~\ref{tab:codeclone_dataset}に示す．
BigCloneBench~\cite{BigCloneBench}は，Javaプロジェクトを対象とした大規模なデータセットである．
詳細については，2.3.1項で述べる．

% % 2．意味的クローンおよび多言語への対応
近年では，同一の処理を行うものの，構文が大きく異なるType4に特化したデータセットや，
多言語を対象としたデータセットが作成されている．
SemanticCloneBench~\cite{SemanticCloneBench}は，Java, Python, C, C\#の4言語にまたがる4,000件のクローンペアを提供する．
また，GPTCloneBench~\cite{GPTCloneBench}は，近年の大規模言語モデル（LLM）の進展を背景に構築された新しいデータセットであり，
Java, Python, C\#における3万件以上のクローンペアが含まれる．

% % 3．機能等価性と検証用オラクル
特定の言語において高い精度で検証を行うためのデータセットも存在する．
FEMPDataset~\cite{FEMPDataset,HigoMSR2022}はJavaの機能等価なメソッドペアに焦点を当てており，高精度な解析が求められる研究で利用されている~\cite{InoueSERA2024,SomeyaICSME2025}．
一方で，Clone oracle~\cite{CloneOracle}は66件と小規模ではあるが，C/C++ におけるクローンペアを提供している．


\begin{table}[!b]
\centering
\caption{既存のコードクローンのデータセット}
\label{tab:codeclone_dataset}
\begin{tabular}{ccr}
\hline
データセット名 & 言語 & データ数 \\ \hline
BigCloneBench~\cite{BigCloneBench} & Java & 8,612,826 \\
Clone oracle~\cite{CloneOracle} & C/C++ & 66 \\
SemanticCloneBench~\cite{SemanticCloneBench} & Java,Python,C,C\# & 4,000 \\
GPTCloneBench~\cite{GPTCloneBench} & Java,Python,C\# & 37,149 \\
FEMPDataset~\cite{FEMPDataset,HigoMSR2022} & Java & 1,342 \\ \hline
\end{tabular}
\end{table}





\subsubsection{BigCloneBench}
% 既存の大規模なベンチマークとその問題点
本研究で用いる，BigCloneBenchは，コードクローン検出器の性能評価で用いられるJavaの大規模なベンチマークである~\cite{BigCloneBench}．
複数のソフトウェアプロジェクトから収集した大規模データセットIJDataset2.0から，特定の機能を実装している可能性のあるソースコードを自動で特定し，
対象の機能を正しく実装しているか否かが手動で判断された．
BigCloneBenchに含まれるクローンペアは，いずれもメソッド単位のコード片から構成される．

BigCloneBenchでは，Type1およびType2のコードクローンは，ソースコードの正規化後テキストの一致を確認することで判定している．
一方，Type3およびType4のコードクローンは，行単位での構文的類似度に基づいて0以上1未満の範囲で，次の5種類に分類される．
この構文的類似度は，行の一致する割合で求められる．

\begin{description}
    \item[Strongly-Type3] 0.7以上1.0未満
    \item[Moderately-Type3] 0.5以上0.7未満
    \item[Weakly-Type3] 0.0以上0.5未満
\end{description}

コードクローンの研究において，Weakly-Type3クローンはType4クローンとして用いられている~\cite{AlamICSME2025,Li2025,LiICSME2017,PinkuICSME2024,WangICSE2023,YuICSE2025,ZhangICCQ2024}．
また，機械学習を用いたコードクローン検出手法において，BigCloneBenchは学習データとして用いられている\cite{Li2025,LiICSME2017,WangICSE2023,YuICSE2025,ZhangICSE2019}．
しかし，BigCloneBenchは分類が不正確で，Type4コードクローンとして扱うには不適切であることが指摘されている~\cite{KrinkeIWSC2022,Krinke2025}. 
BigCloneBenchをType4クローンの検出性能評価に用いる場合，誤った分類の影響で結果の妥当性が脅されるため，
Type4クローンの検出を目標とする，機械学習を用いたコードクローン検出の評価結果に対する信頼性が低下する~\cite{KrinkeIWSC2022,Krinke2025,Yu2022}．


% 検証用(評価用)データとして用いてる~\cite{ZhangICCQ2024},~\cite{AlamICSME2025},~\cite{PinkuICSME2024}
% 学習データとして用いてる~\cite{WangICSE2023},~\cite{YuICSE2025}
% harmfl~\cite{KrinkeIWSC2022}

BigCloneBenchに含まれるそれぞれのTypeに分類されたクローンペアの数は表~\ref{tab:BCB_numbers}に示す通りである．

\begin{table}[!b]
\centering
\caption{BigCloneBenchに含まれるコードクローンの分類}
\label{tab:BCB_numbers}
\begin{tabular}{rrrrrr}
\hline
Type1 & Type2 & Strongly-Type3 & Moderately-Type3 & Weakly-Type3 & 合計\\ \hline
48,116 & 4,234 & 21,966 & 88,306 & 8,450,204 & 8,612,826\\ \hline
\end{tabular}
\end{table}


\subsection{抽象構文木(AST)}
ASTとはソースコードの構文構造を木構造で表現したデータ構造である．
図~\ref{fig:AST_discription}にJavaで書かれたソースコード例とそれに対応するASTを示す．
ASTにおいて，各頂点(ノード)はプログラムを構成する構文要素を表し，各辺はそれら要素間の論理的な親子関係や入れ子構造を表す．
図~\ref{fig:AST_discription}の例では，method\_declarationノードに，五つの子ノードが存在する(modifiers, integral\_type, identifier, formal\_parameters, block)．
これら五つのノードは，method\_declarationノードを親として持つ．
この親子関係に基づき，ASTは階層的な構造を持つ．

以下にASTに関する用語を示す．

\begin{description}
    \item[根ノード] 親を持たないノードを指す~\cite{Fan2021ICSE}．図~\ref{fig:AST_discription}では赤く示されたmethod\_declarationノードである．
    \item[葉ノード] 子を持たないノードを指す~\cite{Fan2021ICSE}．図~\ref{fig:AST_discription}では緑で示されたノードである．斜体で示されているのがそのノードの持つ値である．
\end{description}

\begin{figure}[t]
  \centering
  \includegraphics[width=0.8\textwidth]{images/ast_description.pdf}
  \caption{ソースコード例と対応するAST}
  \label{fig:AST_discription}
\end{figure}

本研究では，AST解析ライブラリとしてTree-sitter~\footnote{https://github.com/tree-sitter/tree-sitter}を用いた．
既存のJava言語を対象とした研究では，AST生成にEclipse JDT\footnote{https://github.com/eclipse-jdt/eclipse.jdt.core}
が広く利用されている~\cite{Falleri2014,TsantalisICSE2018}.
JDTはJava言語専用の解析基盤であるのに対し，Tree-sitterは多言語共通のインターフェースを提供している．
本研究では，Java言語を対象としているが，将来的に他言語への拡張を考えており，
他言語への拡張性が高いことからTree-sitterを選択した．

\section{本研究の動機}

本章では，既存のコードクローン検出手法の問題点，
および既存のデータセットのラベリング基準の不明瞭さという二つの観点から，
本研究の動機について述べる．

\subsection{既存のコードクローン検出手法の問題点}
ソースコードに含まれるコードクローンを検出するため，現在では様々なコードクローン検出ツールが存在する．
現状では，それらのツールは様々なソースコードに対して単一で用いられており，コードクローンの検出を行っている(図~\ref{fig:motivation_1})．
各コードクローン検出ツールは，異なるアルゴリズムを利用してコードクローン検出を行う．
例えば，CCFinder~\cite{KamiyaTSE2002}，NIL~\cite{NIL}は，字句単位の比較を行うことで検出を行う．
Nicad~\cite{Nicad}は行単位の比較を行うことで検出を行う．これは，識別子の正規化やコードの整形といった前処理を適用した後の各行を比較することでコードクローンを検出する．
しかし，単一のコードクローン検出ツールを用いた検出では，偏りがあり，対象ソースコード中に存在する全てのコードクローンを検出できるわけではない．

\begin{figure}[t]
  \centering
  \includegraphics[width=0.5\textwidth]{images/motivation_fig1.pdf}
  \caption{コードクローン検出の現状}
  \label{fig:motivation_1}
\end{figure}

検出されるコードクローンの偏りを軽減するため，複数の検出ツールを対象ソースコードに実行することが考えられる(図~\ref{fig:motivation_2})．
複数のツールを実行することで可能な限り多様なコードクローンの検出を試みる．
しかし，各ツールにおけるコードクローン分類の基準が異なるため，検出後にどのTypeに分類されるかのラベリング結果が統一されない問題が起こる．
例えば，ある関数Aとある関数Bがツール1によってType3として検出された場合に，別のツール2では，Type4として検出される場合がある．
また，コードクローンの大規模データベース作成の際にも，この問題が発生する．
ツールごとにラベリング結果が異なるため，データの統合ができない．
さらには，コードクローンの検出は行うものの，ラベリングを行わないツールも存在する．
そのため，複数のクローン検出結果をそのラベリングも含めて単一のデータセットとして扱うことはできない．

\begin{figure}[t]
  \centering
  \includegraphics[width=0.8\textwidth]{images/motivation_fig2.pdf}
  \caption{コードクローン検出の問題}
  \label{fig:motivation_2}
\end{figure}

この問題を解決するため，提案手法では，コードクローン検出の後処理としての統一的なラベリングを行う(図~\ref{fig:motivation_3})．
これにより，複数ツールから検出されたコードクローンに一貫した分類に基づいたラベリングを行うことができる．
統一的なラベリングを行うことで，それぞれのツールの検出結果を単一のデータセットに統合することが可能となる．
これにより，コードクローン情報の質が向上し，コードクローンデータを他の研究や開発に利用しやすくなる．
例えば，LLMの学習用データとしての利用が挙げられ，LLMベースの超高精度なクローン検出の実現が見込まれる．

\begin{figure}[t]
  \centering
  \includegraphics[width=1\textwidth]{images/motivation_fig3.pdf}
  \caption{提案手法による解決策}
  \label{fig:motivation_3}
\end{figure}

提案手法を用いて，ソースコード中のコードクローンの検出を行うわけでなく，
コードクローン検出後のラベリングを行ったのは，実行時間の問題からである．
対象関数の数を$n$とした場合，提案手法の実行回数は$n^2$となる．
提案手法では，抽象構文木を用いて分類を行っており，二つの木を比較すること自体が非常に重い処理である．
全ての関数のペアを比較して結果を得ることは時間的に現実的ではない．
また，提案手法は入力をクローンペアと想定しているため，一定以上の差異がある場合にType4として判定している．
そのため，提案手法はクローンペアではない関数のペアが与えられた場合にそれがクローンペアではないのか，もしくはType4クローンなのかが判定できない．
これらのことから，提案手法ではコードクローン検出後に限定した統一的なラベリングを行う．

\subsection{既存データセットにおけるラベリングの問題点}

BigCloneBench~\cite{BigCloneBench}は，既存のコードクローンデータセットの中で最大規模のデータセットである．
BigCloneBenchでは，Type1およびType2のコードクローンは，ソースコードの正規化後テキストの一致を確認することで判定している．
一方，Type3およびType4のコードクローンは，行単位での構文的類似度に基づいて0以上1未満の範囲で，3種類に分類される．
この構文的類似度は，行の一致する割合で求められる．
具体的には，行単位の類似度が0.7以上1.0未満のペアをStrongly-Type3，0.0以上0.5未満のペアをWeakly-Type3と定義している．

しかし，類似度という数値指標に基づく分類は，解析の単位粒度に結果が大きく左右される．
そこで本研究では，行単位の類似度による分類結果が，字句という異なる単位を用いた場合にどの程度変動するかを調査した．
具体的には，BigCloneBenchに含まれるStrongly-Type3，Moderately-Type3，Weakly-Type3のコードクローンについて，
字句単位で比較を行い，一致率を計算した．
字句単位の類似度算出にあたっては，二つのトークン列間における最長共通部分系列(LCS: Longest Common Subsequence)~\cite{Hunt1977,Wagner1974}を用いた．
LCSは，トークンの出現順序を維持したまま，共通して現れる最長の系列を特定する手法である．
単純な語彙の集合比較とは異なり，ソースコードの論理的な記述順序を反映した類似度を計測できるため，本分析の指標として採用した．
具体的には，クローンペアの各トークン列を$S_1, S_2$としたとき，
以下の式により類似度$Sim_{LCS}$を算出した．
$$Sim_{LCS}(S_1, S_2) = \frac{|LCS(S_1, S_2)|}{\max(|S_1|, |S_2|)}$$

\begin{figure}[!t]
  \centering
  \includegraphics[width=0.9\textwidth]{images/lcs_probablitiy_hist_tokenized.pdf}
  \caption{字句単位の類似度における行一致率の分布}
  \label{fig:line_to_lcs}
%   \vspace{0.5em} % キャプションとの間隔を微調整
  {\footnotesize \textbf{注：} 赤い破線は，BigCloneBenchにおけるWeakly-Type3とModerately-Type3の
  閾値である0.5と，Moderately-Type3とStrongly-Type3の閾値である0.7を表している}
\end{figure}

% \begin{figure}[!t]
%   \centering
%   \includegraphics[width=0.9\textwidth]{images/similarity_line_distribution_by_lcs_ratio.pdf}
%   \caption{各行一致率における字句単位の類似度の分布}
%   \label{fig:lcs_to_line}
%   {\footnotesize \textbf{注：} 赤い破線は，BigCloneBenchにおけるWeakly-Type3とModerately-Type3の
%   閾値である0.5と，Moderately-Type3とStrongly-Type3の閾値である0.7を表している}
% \end{figure}

算出結果を図~\ref{fig:line_to_lcs}に示す．
解析の結果，行単位の分類と字句レベルの類似度の間には顕著な乖離が確認された．
例えば，Strongly-Type3に分類されていたクローンペアについて，字句単位の類似度が閾値である0.7より小さくなるペアが存在し．
また，Weakly-Type3についても，字句単位の類似度が閾値である0.5より大きくなるペアが存在した．

以上の知見は，
行単位や字句単位の類似度に基づく分類基準が単位粒度に依存して一貫性がないことを示唆しており，
類似度を用いない新たな分類基準が必要であることを示す．
したがって，本研究では類似度という数値的な閾値判定に依存せず，ASTの構造的特徴に基づいた新たなType分類の定義を導入する．
ASTに基づいた分類基準を設けることで，解析の単位粒度に結果が左右されることなく，プログラムの論理的な構造に根ざした客観的な分類が可能となる．

\section{提案手法}
本章では，本研究で提案するコードクローン検出の後処理としての統一的なラベリング手法について述べる．
提案手法では，クローンペアを入力し，そのクローンペアがどのTypeに分類されるかのラベルを出力とする．


\subsection{分類基準}

\begin{figure}[!t]
  \centering
  \includegraphics[width=0.8\textwidth]{images/ast_type1.pdf}
  \caption{Type1の例}
  \label{fig:AST_type1}
\end{figure}

本研究ではASTに基づいて新たな分類基準を定義した．
定義は以下の通りである．
すでにコードクローンとして検出されたコードが対象で，
与えられたクローンペアをそれぞれASTに変換し，二つのASTの差に応じて分類を行う．

\begin{description}
    \item[Type1] ASTが完全一致するコードクローン
    \item[Type2] 葉ノードを除いてASTが一致するコードクローン
    \item[Type3] 葉ノードに加え，単文以下のノードを除いてASTが一致するコードクローン
    \item[Type4] 上記に分類されないコードクローン
\end{description}

Type1〜3の分類基準について詳細を述べる．


Type1では葉ノードの持つ値を含むAST全体が完全に一致する(図~\ref{fig:AST_type1})．
ASTの木の形状と，斜体で示された値が完全に同一である場合，Type1と判断される．

Type2では葉ノードを除いたASTが一致する．
% 本研究では，2.1節で示したコードクローン研究における標準的な定義に従い，演算子を構文構造の一部として扱うため，演算子を葉ノードから除いた．
% ASTにおける演算子の表現形式はパーサの実装仕様に強く依存する．
% 例えば，一部のパーサでは演算子が二項演算ノードの下位に独立した葉ノードとして定義されるが，
% 別のパーサではノード自体の属性値として保持される．
本手法において，演算子は葉ノードとして扱わない．この理由は，計算処理の種類を厳密に区別するためである．
Type2のコードクローンは識別子やリテラルの置換を許容するが，演算子の変更は計算手順そのものの変容を意味する．
例えば，$a + b$ と $a \times b$ はASTの形状は同一であるが，計算アルゴリズムとしては異なり，演算子が他の葉ノードと同様に除かれ比較されると，これらは同一のType2クローンとして判定されてしまう．
% このように，論理的に異なる処理内容を持つペアを同一視する「過度な抽象化」は，クローン判定の信頼性を損なう恐れがある．
したがって，本手法では演算子を識別子やリテラル値と区別して扱い葉ノードから除いた．
図~\ref{fig:AST_type2}に示した例では，赤く示した部分がソースコード上で異なる部分である．
葉ノードとして除かれるノードを灰色で，比較対象として残るノードを黒で示している．
黒く示されたノードを持つASTの形状が同一であるため，Type2と判断される．


\begin{figure}[!t]
  \centering
  \includegraphics[width=0.8\textwidth]{images/ast_type2.pdf}
  \caption{Type2の例}
  \label{fig:AST_type2}
\end{figure}


\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.8\textwidth]{images/ast_type3.pdf}
  \caption{Type3の例}
  \label{fig:AST_type3}
\end{figure}

Type3では単文以下のノードを除いたASTが一致する．
% 単文として定義するノードを表~\ref{tab:statement_nodes}示す．これらはTree-sitterで用いられるノードで定義される．これらのノードを親ノードとして持つノードもType3では除かれる．
Javaにおいて，単文として定義される文を表~\ref{tab:statement_java}に示す．
図~\ref{fig:AST_type3}に示した例では，葉ノードに加え，return\_statementノード，expression\_statementノードが単文にあたるため，
これらのノード以下のノードが除かれる．黒く示されたノードを持つASTの形状が同一であるため，Type3と判断される．

\begin{table}[!b]
\centering
\caption{Javaにおいて単文として定義される文の例}
\label{tab:statement_java}
\begin{tabular}{lp{10cm}} 
\hline
\textbf{単文} & \textbf{例} \\ \hline
\multirow{2}{*}{式文} & x = a + b; \\
 & System.out.println(s);\\
変数宣言文 & int count = 0; \\
return文 & return result; \\
throw文 & throw new IllegalArgumentException(); \\
break文 & break; \\
continue文 & continue; \\
yield文 & yield 100; \\
assert文 & assert list != null;  \\ \hline
\end{tabular}
\end{table}

% BigCloneBenchにこの研究での分類を追加したデータセットを作るようにいったはず．それに対する記述が必要．
% データセットのサイズや分布（オリジナルとの比較含む）．データセットの作成に要した時間，使ったPCのスペック．
% この修論では被験者実験しかできていないが，今後はもっと実験必要ははずです．
% 時間がないからしかたなく被験者実験に落とし込んだはず．どのようなことをする必要があるのかを書いてください．
% if や while ブロックの条件式部分について，どのようにあつかっているのかの記述がない．できれば図も追加．現在の図（図５～７）をそのように変えてもよい

提案手法の分類定義におけるif文，while文，for文等の制御構造を持つソースコードの扱いについて述べる．
図~\ref{fig:AST_type4}に同じ機能を持つJavaプログラムと対応するASTを示す．
簡単のため，一部のノードを省略している．
この二つのコードでは，同じ処理を行うものの，一方はwhile文を，他方はfor文を用いて処理を行っている．
ASTにおいて，葉ノードおよび単文以下のノードとして除かれるノードを灰色で示す．
黒く示すノードを持つASTの形状が異なるため，Type4に分類される．
ここで，while文およびfor文の条件式内の文について，単文として扱われないため，
葉ノード以外のノードは除かれることなくASTの形状の比較が行われる．

\begin{figure}[!t]
  \centering
  \includegraphics[width=0.8\textwidth]{images/ast_type4.pdf}
  \caption{制御構造を持つコードの例}
  \label{fig:AST_type4}
\end{figure}


\section{評価実験}
本章では，評価実験について述べる．
本実験は，BigCloneBenchが行単位での構文的類似度に基づいて分類した場合と，提案手法で分類した場合のどちらがより人間の感覚に近いのかを評価することを目的としている．
特に，分類の基準が明確でないType3およびType4のコードクローンを対象とした．

\subsection{実験対象データセット}

% \subsection{BigCloneBenchの分類結果}
実験対象データセットとしてBigCloneBenchを用いた．
コードクローンの研究において，Strongly-Type3はType3クローンとして，
Weakly-Type3クローンはType4クローンとして用いられている~\cite{AlamICSME2025,Li2025,LiICSME2017,PinkuICSME2024,WangICSE2023,YuICSE2025,ZhangICCQ2024}．
提案手法を用いてBigCloneBenchに含まれるクローンペアに対して分類を行った．
分類には，AppleM3チップ(8コアCPU)，メモリ24GBのMacBookAirを使用した．
Javaのバージョンは25.0.1を利用した．
提案手法を用いてBigCloneBench内のクローンペアの分類を行った結果を表~\ref{tab:BCB_type}に示す．
分類に要した総時間は35時間49分であった．

\begin{table}[!b]
\centering
\caption{提案手法によるBigCloneBenchの分類結果}
\label{tab:BCB_type}
% \small % 文字サイズを少し下げて収まりやすくします
% \setlength{\tabcolsep}{3pt} % 列間の余白をわずかに詰め、横幅を稼ぎます
\begin{tabular}{ccrrrrrr}
\hline
& & \multicolumn{5}{c}{BigCloneBench} & \\ \cline{1-8}
 & & Type1 & Type2 & \makecell{Strongly-\\Type3} & \makecell{Moderately-\\Type3} & \makecell{Weakly-\\Type3} & 合計\\ \hline
\multirow{4}{*}{提案手法} & Type1 & 48,116 & 0 & 0 & 0 & 0 & 48,116 \\
& Type2 & 0 & 4,234 & 3,637 & 12  & 1 & 7,884 \\
& Type3 & 0 & 0 & 7,984 & 13,302 & 46,973 & 68,259 \\
& Type4 & 0 & 0 & 10,345 & 74,992 & 8,403,230 & 8,488,567 \\ \hline
& 合計 & 48,116 & 4,234 & 21,966 & 88,306 & 8,450,204 & 8,612,826 \\ \hline
\end{tabular}
\end{table}

% BigCloneBenchのStrongly-Type3，Moderately-Type3，Weakly-Type3に分類されるクローンペアのうち，提案手法でType2と判断されたクローンペアの例をListing~\ref{code:type２}に示す．修飾子が異なるため，BigCloneBenchではModerately-Type3に分類されていた．


% \begin{lstlisting}[caption={Type2と判断されたクローンペアの例}, label={code:type２}]
% // --- id 4644121 ---
% protected void copy (Reader reader, OutputStream outputs) throws IOException {
%     IOUtils.copy (reader, outputs);
% }

% // --- id 11088627 ---
% public static void copyWithoutClose (InputStream is, OutputStream os) throws IOException {
%     IOUtils.copy (is, os);
%     }
% \end{lstlisting}




\subsection{実験手順}
被験者はコンピュータサイエンスを専攻する博士前期課程の大学院生6人であり，いずれもJavaを用いたプログラミングの経験がある．
以下のいずれかの基準を満たすクローンペアを本研究の調査対象とした．
ペアを構成する二つのメソッドの合計トークン数が少ない順にそれぞれ50個，合計100個のクローンペアを対象とした．
同一のメソッドが複数のペアに含まれる場合は，そのうち一組のみを抽出対象とした．

\begin{itemize}
    \item BigCloneBenchでStrongly-Type3に分類されるクローンペアのうち提案手法でType4と分類されたクローンペア
    \item BigCloneBenchでWeakly-Type3に分類されるクローンペアのうち提案手法でType3と分類されたクローンペア
\end{itemize}

被験者には，事前に，2.1節に記述したコードクローン分類の定義を提示し，100個のクローンペアがどちらに分類されるべきかを判断してもらった．
また，判断に迷った場合にその理由と最終的な判断の理由についても回答してもらった．





\section{実験結果と考察}

本章では評価実験の結果とそれに対する考察を述べる．

\subsection{実験結果}

\begin{figure}[t]
  \centering
  \includegraphics[width=0.8\textwidth]{images/agreement_bar_chart.pdf}
  \caption{評価実験の結果：被験者の判断の割合}
  \label{fig:result_experimet}
  {\footnotesize \textbf{注：} Stronglyは，BigCloneBenchによってStrongly-Type3と分類されるクローンペアのうち
  提案手法でType4と分類されたクローンペアを示し，
  Weaklyは，BigCloneBenchによってWeakly-Type3と分類されるクローンペアのうち
  提案手法でType3と分類されたクローンペアを示す．}
\end{figure}

\begin{figure}[t]
  \centering
  \includegraphics[width=1\textwidth]{images/agreement_violin_plot.pdf}
  \caption{評価実験の結果：被験者の分布}
  \label{fig:result_experimet_violin}
  {\footnotesize \textbf{注：} Stronglyは，BigCloneBenchによってStrongly-Type3と分類されるクローンペアのうち
  提案手法でType4と分類されたクローンペアを示し，
  Weaklyは，BigCloneBenchによってWeakly-Type3と分類されるクローンペアのうち
  提案手法でType3と分類されたクローンペアを示す．}
\end{figure}



結果を図~\ref{fig:result_experimet}に示す．
BigCloneBenchでStrongly-Type3に分類されるクローンペアのうち提案手法でType4と分類されたクローンペアは，
28.3\%がType4と判断され，提案手法による分類が人間の感覚に反するという結果になった．
一方，Weakly-Type3に分類されるクローンペアのうち提案手法でType3と分類されたクローンペアは，
71.0\%がType3と判断され，提案手法による分類が人間の感覚に近いという結果になった．
また，全体的にType3と判断されたクローンペアの数が多かった．

\begin{table}[!b]
\centering
\caption{提案手法と一致する判断を行った人数の分布}
\label{tab:result_plot}
\begin{tabular}{crrrrrrr}
\hline
 & 0人 & 1人 & 2人 & 3人 & 4人 & 5人 & 6人\\ \hline
Strongly & 3 & 22 & 14 & 9 & 2 & 0 & 0 \\ 
Weakly & 0 & 2 & 0 & 15 & 8 & 16 & 9 \\ \hline
% 時間　&  & 9:55 min &  40.8 s & 4:34 min & 10:29 min & 1 d 11:23 h \\ \hline
\end{tabular}

\smallskip % 少し隙間を空ける
\begin{minipage}{0.6\textwidth} % 表の幅に合わせるための指定
    \footnotesize
    % \textbf{注：} Stronglyは，BigCloneBenchによってStrongly-Type3と分類されるクローンペアのうち
    % 提案手法でType4と分類されたクローンペアを示し，Weaklyは，BigCloneBenchによってWeakly-Type3と
    % 分類されるクローンペアのうち提案手法でType3と分類されたクローンペアを示す．
\end{minipage}
\end{table}

提案手法の判定と一致した被験者数ごとのクローンペア分布を図~\ref{fig:result_experimet_violin}に，
その具体的な内訳となるペア数を表~\ref{tab:result_plot}に示す．
図~\ref{fig:result_experimet_violin}における分布の詳細は，表~\ref{tab:result_plot}の数値に対応している．
Strongly-Type3に分類されるクローンペアのうち提案手法でType4と分類されたクローンペアは，
分布の偏りから，判断に迷いが少ないことがわかる．
一方，Weakly-Type3に分類されるクローンペアのうち提案手法でType3と分類されたクローンペアは，
BigCloneBenchの分類を選んだのが3人，提案手法の分類を選んだのが3人である場合，つまり意見が割れたクローンペアが
多く存在することから，判断の迷いがあったと考える．

Strongly-Type3に分類されるクローンペアのうち提案手法でType4と分類されたクローンペア，
Weakly-Type3に分類されるクローンペアのうち提案手法でType3と分類されたクローンペア，それぞれについて，
被験者による判断と提案手法による分類が一致した場合，異なった場合のコードを確認した．
以降に詳細を述べる．


\subsubsection{Strongly-Type3に分類されるクローンペアのうち提案手法でType4と分類されたクローンペア}
本項では，BigCloneBenchによってStrongly-Type3と分類されたものの，提案手法ではType4と判定されたクローンペアについて詳細を述べる．
実験の結果，提案手法の分類は人間の感覚に反するという結果になった．
表~\ref{tab:result_plot}に示されているように，
被験者6人のうち，6人全員がType4と判断したクローンペアは存在せず，
最大で4人がType4と判断したクローンペアは，50ペア中2ペアに留まった．
一方で，被験者全員がType3と判断したクローンペアは3ペア存在した．
それぞれのクローンペアについて例を示して詳細を述べる．

\medskip % ここに空行が入る

\begin{minipage}{\textwidth}
    \centering
    % キャプションを上に置く場合はここに記述（名前を揃えるため）
    \makeatletter
    \def\@captype{lstlisting}
    \makeatother
    \caption{被験者6人中4人が提案手法と同じType4と判断したクローンペアの例}
    \label{code:experimet_pair56}

    % 1つ目のコード
    \begin{lstlisting}[
        escapechar=|,  % エスケープ文字として | を指定
        basicstyle=\small\ttfamily]
public static final void randomShuffle (int [] v, Random r) {
    while (-- n > 0) {
        int k = r.nextInt (n + 1);
        int temp = v [n];
        v [n] = v [k];
        v [k] = temp;
    }
}
    \end{lstlisting}

    \vspace{0.5em} % コード間の隙間

    % 2つ目のコード
    \begin{lstlisting}[
        escapechar=|,  % エスケープ文字として | を指定
        basicstyle=\small\ttfamily]
public static synchronized void shuffle (int [] anArray) {
    int n = anArray.length;
    for (int i = n - 1; i >= 1; i --) {
        int j = randomSource.nextInt (i + 1);
        int temp = anArray [j];
        anArray [j] = anArray [i];
        anArray [i] = temp;
    }
}
    \end{lstlisting}
\end{minipage}

\medskip % ここに空行が入る

ソースコード~\ref{code:experimet_pair56}は被験者6人中4人が提案手法と同じType4と判断したクローンペアである．
このクローンペアでは，一方がwhile文，他方がfor文という異なる制御構造を含んでいるため，
ASTの構造的差異に基づき，提案手法ではType4と判定された．
この例のように制御構造そのものが異なるクローンペアに対しては，
提案手法による分類が被験者の主観評価に近いことが確認された．

% \noindent % インデントを無効化
\begin{minipage}{\textwidth}
    \centering
    % キャプションを上に置く場合はここに記述（名前を揃えるため）
    \makeatletter
    \def\@captype{lstlisting}
    \makeatother
    \caption{被験者全員が提案手法とは異なるType3と判断したクローンペアの例(while文の条件式の違い)}
    \label{code:experimet_pair34}

    % 1つ目のコード
    \begin{lstlisting}[
        escapechar=|,  % エスケープ文字として | を指定
        basicstyle=\small\ttfamily]
private void writeFile (FileInputStream inFile, FileOutputStream outFile) throws IOException {
    byte [] buf = new byte [2048];
    int read;
    while (|\textcolor{red}{(read = inFile.read (buf)) > 0 \&\& ! stopped}|) outFile.write (buf, 0, read);

    inFile.close ();
}
    \end{lstlisting}

    \vspace{0.5em} % コード間の隙間

    % 2つ目のコード
    \begin{lstlisting}[
        escapechar=|,  % エスケープ文字として | を指定
        basicstyle=\small\ttfamily]
private void writeFile (FileInputStream inFile, FileOutputStream outFile) throws IOException {
    byte [] buf = new byte [2048];
    int read;
    while (|\textcolor{red}{(read = inFile.read (buf)) > 0}|) outFile.write (buf, 0, read);

    inFile.close ();
}
    \end{lstlisting}
\end{minipage}

\medskip % ここに空行が入る

次に，被験者全員が提案手法と異なるType3と判断したクローンペアを示す．
ソースコード~\ref{code:experimet_pair34}は，赤く示されたwhile文の条件式においてASTに差異が生じたため，提案手法ではType4と判断された．
しかし，被験者の判断では，条件式のみの変更は，文の変更に相当し，Type3の定義の範疇に収まるとしてType3と判断していた．
現在の定義では，while文，if文，for文等の制御構造において，条件式内の文は単文に含まれない．
そのため，内包される条件式のAST構造が異なる場合は一律にType4と判定される．
% 今後は，制御構文内の条件式における軽微な変更を許容するよう判定ロジックを修正することで，より人間の直感に近い分類が可能になる．
単文として定義される文に制御構造内の条件式を含めることで，より人間の直感に近い分類が可能になる．


\begin{minipage}{\textwidth}
    \centering
    % キャプションを上に置く場合はここに記述（名前を揃えるため）
    \makeatletter
    \def\@captype{lstlisting}
    \makeatother
    \caption{被験者全員が提案手法と異なるType3と判断したクローンペアの例(仮引数の違い)}
    \label{code:experimet_pair57}

    % 1つ目のコード
    \begin{lstlisting}[
        escapechar=|,  % エスケープ文字として | を指定
        basicstyle=\small\ttfamily]
public static final void copy (|\textcolor{red}{InputStream is, OutputStream os}|) throws IOException {
    try {
        IOUtils.copy (is, os);
    } finally {
        IOUtils.closeQuietly (is);
        IOUtils.closeQuietly (os);
    }
}
    \end{lstlisting}

    \vspace{0.5em} % コード間の隙間

    % 2つ目のコード
    \begin{lstlisting}[
        escapechar=|,  % エスケープ文字として | を指定
        basicstyle=\small\ttfamily]
public static void readFile (|\textcolor{red}{FOUserAgent ua, String uri, OutputStream output}|) throws IOException {
    InputStream in = getURLInputStream (ua, uri);
    try {
        IOUtils.copy (in, output);
    } finally {
        IOUtils.closeQuietly (in);
    }
}
    \end{lstlisting}
\end{minipage}

\medskip % ここに空行が入る

ソースコード~\ref{code:experimet_pair57}は，メソッドの仮引数が異なっていたため，
ASTに差異が生じ，提案手法ではType4と判断された．
しかし，被験者は，仮引数の違いもType3における文の変更の一部であると判断した．
引数の数や順序の変更についても，条件式と同様に，
単文として定義される文に仮引数を含めることで，より人間の直感に近い分類が可能になる．




\subsubsection{Weakly-Type3に分類されるクローンペアのうち提案手法でType3と分類されたクローンペア}

本項では，BigCloneBenchでWeakly-Type3に分類されるペアのうち，提案手法によってType3と判定されたケースについて述べる．
実験の結果，提案手法の分類が人間の感覚に近いという結果になった．
具体的には，被験者6人全員が Type-3 と判断したペアが9件存在した．
一方で，被験者全員がType4と判断したペアは存在せず，最大で5人がType4と判断したペアが50件中2件確認された．
以下にその詳細を述べる．

\begin{minipage}{\textwidth}
    \centering
    % キャプションを上に置く場合はここに記述（名前を揃えるため）
    \makeatletter
    \def\@captype{lstlisting}
    \makeatother
    \caption{被験者全員が提案手法と同じType3と判断したクローンペアの例}
    \label{code:experimet_pair11}

    % 1つ目のコード
    \begin{lstlisting}[
        escapechar=|,  % エスケープ文字として | を指定
        basicstyle=\small\ttfamily]
private byte [] generateHash (String s) throws NoSuchAlgorithmException {
    MessageDigest md = MessageDigest.getInstance ("MD5");
    md.update (s.getBytes ());
    return md.digest ();
}
    \end{lstlisting}

    \vspace{0.5em} % コード間の隙間

    % 2つ目のコード
    \begin{lstlisting}[
        escapechar=|,  % エスケープ文字として | を指定
        basicstyle=\small\ttfamily]
private static byte [] finalizeStringHash (String loginHash) throws NoSuchAlgorithmException {
    MessageDigest md5Hasher;
    md5Hasher = MessageDigest.getInstance ("MD5");
    md5Hasher.update (loginHash.getBytes ());
    md5Hasher.update (LOGIN_FINAL_SALT);
    return md5Hasher.digest ();
}
    \end{lstlisting}
\end{minipage}

\medskip % ここに空行が入る

ソースコード~\ref{code:experimet_pair11}は，被験者全員が提案手法と同じType3と判断したクローンペアである．
このクローンペアでは，互いに共通する文を多く含んでおり，被験者はその内容の類似性からType3と判断したと考えられる．
しかし，BigCloneBenchではWeakly-Type3として扱われ，人間の感覚と反する．
このように，BigCloneBenchの分類が人間の直感と反するケースが存在することが確認できた．
これは，BigCloneBench の分類基準である行単位の類似度という指標ではなく，
ASTを用いることで，プログラムの論理的な骨組みを直接評価できることが，人間の感覚に近い判定に寄与したと言える．
提案手法の分類基準が，既存の類似度に基づくよりもコードクローンの実態をより正確に反映できる可能性を示している．


\medskip % ここに空行が入る

\begin{minipage}{\textwidth}
    \centering
    % キャプションを上に置く場合はここに記述（名前を揃えるため）
    \makeatletter
    \def\@captype{lstlisting}
    \makeatother
    \caption{被験者6人中5人が提案手法と異なるType4と判断したクローンペアの例}
    \label{code:experimet_pair55}

    % 1つ目のコード
    \begin{lstlisting}[
        escapechar=|,  % エスケープ文字として | を指定
        basicstyle=\small\ttfamily]
private void javaToHtml (File source, File destination) throws IOException {
    Reader reader = new FileReader (source);
    Writer writer = new FileWriter (destination);
    JavaUtils.writeJava (reader, writer);
    writer.flush ();
    writer.close ();
}
    \end{lstlisting}

    \vspace{0.5em} % コード間の隙間

    % 2つ目のコード
    \begin{lstlisting}[
        escapechar=|,  % エスケープ文字として | を指定
        basicstyle=\small\ttfamily]
public static void copy (InputStream stream, OutputStream ostream) throws IOException {
    IOUtils.copy (stream, ostream, false);
}
    \end{lstlisting}
\end{minipage}

\medskip % ここに空行が入る

一方，ソースコード~\ref{code:experimet_pair55}は，被験者6人のうち5人が提案手法と異なるType4と判断したクローンペアである．
このクローンペアでは，機能は同一であるが，構文的に異なるとして被験者はType4と判断していた．
提案手法は，それぞれのメソッド以下の文を全て単文として扱ったために，
単文以下のノードを除いた後のASTの形状が同一となり，Type3と判断され，人間の判断との乖離が発生していた．







\subsection{考察}

\subsection{提案手法の分類定義}

6.1.1項の結果から，提案手法の厳密な構造比較はType4の特定に寄与する一方で，
人間が，2.1節に示したType3の定義として許容する範囲のコードクローンを
Type4と判定する可能性が示唆された．
これらの知見に基づき，特定の構文要素に対する判定基準を柔軟に調整することが，
今後の精度向上における重要な課題である．

6.1.2項の例に対し，提案手法がType3と判定した要因は，単文以下のノードを除いた後のASTの形状が同一であったためである．
しかし，極端な例として，メソッド本体が一つの単文のみで構成されるコードと，大量の単文を含むコードであっても，
それらが同じ制御構造の中に配置されていれば，本手法ではASTが同一であると見なされ，Type3に分類されてしまう．
実験の結果，このような規模の著しい乖離がある場合にType3と分類することは，人間の直感から離れる原因になると示唆された．
したがって，単文以下のノードを除く際，何らかの制約を設ける必要があると考えられる．
具体的な改善策として，次の2点が考えられる．
% \begin{itemize}
%     \item 単文の数による制約：追加または削除された単文の数に閾値を設け，構文的な乖離が一定範囲を超えないように制限する方法である．
%     \item 文の種類や文脈に応じたフィルタリング：ソースコード中の全ての単文を一律に取り除くのではなく，例えばメソッド呼び出しを伴う文の変更のみを個別に評価するなど，変更を許容する要素を文脈に応じて動的に選択する方法である．
% \end{itemize}
% まず，単文の数によって制限する．これは，単純に追加される，または削除される単文の数に閾値を設けることで，
% 構文的にかけ離れないようにする方法である．
% 次に，メソッド呼び出し直後の単文の変更のみをみるなどの，
% ソースコード中の単文に対して変更を許容するか否かのフィルターを設ける方法である．

\begin{itemize} 
    \item 単文の数による量的制約：
    追加，削除または変更されたとする単文の数に閾値を設け，ソースコード全体の文の量が著しく異なる場合には，Type3判定しないように制限する方法である．
    例えば，挿入された文の数が元の構造に対して一定の割合を超える場合，それをType3ではなくType4と判定する．
    \item 文の種類や文脈に応じたフィルタリング：
    ソースコード中の全ての単文を一律に取り除くのではなく，文の内部構造(例：メソッド呼び出しの有無)に応じて，
    その単文を除くか，保持するかを判定する方法である． 
    変更を許容する要素を文脈に応じて動的に選択することで，単なる変数への代入といった軽微な実装の差異は除き，
    外部ライブラリの呼び出しを伴うような重要なコードの変更を保持することが可能となる．
\end{itemize}

これらの変更により，より人間の直感に近い分類が可能になると考えられる．

\subsubsection{被験者ごとの傾向}
本実験における被験者ごとの傾向を調査するため，回答の分析を行なった．
被験者ごとのType3と判断したペア数を表~\ref{tab:user_type3_numbers}に，
被験者間の回答の一致率を表~\ref{tab:user_agreement_heatmap}に示す．


\begin{table}[!b]
\centering
\caption{被験者ごとのType3と判断したペア数(100ペア中)}
\label{tab:user_type3_numbers}
% \small % 表全体の文字サイズを少し小さく調整
\begin{tabular}{lcccccc}\hline
 & P1 & P2 & P3 & P4 & P5 & P6 \\ \hline
ペア数 & 75 & 66  & 53 & 78 & 82 & 74 \\ \hline
\end{tabular}
\end{table}

\begin{table}[!b]
\centering
\caption{被験者間における実験回答の一致率}
\label{tab:user_agreement_heatmap}
\begin{tabular}{lcccccc}\hline
 & P1 & P2 & P3 & P4 & P5 & P6 \\ \hline
P1 & -- & \cellcolor{high_val}\textbf{75\%} & \cellcolor{mid_val}64\% & 55\% & \cellcolor{mid_val}63\% & 57\% \\
P2 & \cellcolor{high_val}\textbf{75\%} & -- & \cellcolor{mid_val}63\% & 46\% & 52\% & 54\% \\
P3 & \cellcolor{mid_val}64\% & \cellcolor{mid_val}63\% & -- & 39\% & 45\% & 51\% \\
P4 & 55\% & 46\% & 39\% & -- & \cellcolor{high_val}\textbf{78\%} & \cellcolor{high_val}\textbf{76\%} \\
P5 & \cellcolor{mid_val}63\% & 52\% & 45\% & \cellcolor{high_val}\textbf{78\%} & -- & \cellcolor{high_val}\textbf{74\%} \\
P6 & 57\% & 54\% & 51\% & \cellcolor{high_val}\textbf{76\%} & \cellcolor{high_val}\textbf{74\%} & -- \\ \hline
\end{tabular}

\smallskip
\begin{minipage}{0.65\textwidth} % 表の幅に合わせて調整
    \footnotesize
    \textbf{注：} セルの背景色は、一致率が70\%以上のものを濃色、60\%以上のものを淡色で示している。
\end{minipage}
\end{table}
% P1: ta1kmr: g-kimura: i-kondou: c-yosida: tk-kawam: ry-inoue


表~\ref{tab:user_agreement_heatmap}の被験者間の一致率に基づき，
被験者を二つのグループに分類した．
具体的には，P1，P2，P3からなるグループAとP4，P5，P6からなるグループBである．
グループA内では，P1とP2の間で70\%以上の一致率が確認され，P3もP1およびP2とそれぞれ60\%以上の一致率を示した．
対してグループBでは，P4からP6の全被験者間でそれぞれ70\%以上の高い一致率を記録した．
これら二つのグループについて回答の判断理由を分析した結果，両者の間でクローン判定の基準が明確に異なることが判明した．
具体的には，処理機能の同一性を重視する立場と，評価の際に構文構造の差異を重視する立場の違いである．
グループAは，2.1節のType4の定義に基づき，同一の処理を行う場合にType4と判断し，行わない場合にType3と判断していた．
一方，グループBは，2.1節のType3の定義に基づき，クローンペア間で異なる部分が，文の挿入，削除，変更に留まる場合にはType3と判断し，
それ以上の構文の変更が見られる場合にType4と判断していた．
このような被験者間における判断基準の不一致が，同一のクローンペアに対して異なる分類が行われる要因になったと考えられる．
以上の結果は，コードクローンにおけるType3とType4の定義の曖昧さを示唆しており，
本研究が目的とする統一的なラベリング手法の必要性が改めて確認された．




\section{妥当性への脅威}

本章では，本研究における内部妥当性，外部妥当性，結論妥当性への脅威について述べる．

\subsection{内部妥当性}
内部妥当性への脅威としては，提案手法の実装および解析基盤として採用したTree-sitterの精度が挙げられる．
パーサによる構文解析に誤りが含まれる場合，正しくラベリングが行われない可能性がある．
これに対し，本研究では解析対象の各文に対し，生成されたASTノードが意図した構文要素と一致しているかを事前にテストを用いて検証し，
実装の正確性を確認している．

また，評価実験における被験者の主観性も脅威となり得る．
考察で述べた通り，被験者の判断基準が，構文の変更を重視する立場と機能の同一性を重視する立場の二つに類別されることが確認された．
実験前の教示においてコードクローンの定義を説明しているが，被験者個人の経験や直感に起因する判断のブレを完全に排除することは困難である．
この影響を軽減するため，本研究では被験者間の回答一致率を算出し，主観による偏りを定量的に評価している．

\subsection{外部妥当性}
外部妥当性への脅威は，結果の汎用性に関するものである．
本研究では評価対象を Java 言語に限定しており，他のプログラミング言語（Python や C++ 等）における有効性は未検証である．
しかし，採用した Tree-sitter は多言語対応の解析基盤であり，
他言語への拡張は比較的容易であると考えられる．
Java以外の言語への拡張と，拡張した提案手法の評価は今後の課題である．

また，サンプリングにおいてトークン数の合計が少ないペアを優先的に抽出したため，大規模なメソッドにおける精度については更なる検証が必要である．
さらに，本研究ではBigCloneBenchのみを評価対象としたが，
特定のドメインや特定の開発手法（テストコード等）におけるクローン特性が，本手法の分類精度に影響を与える可能性がある．
BigCloneBench以外のデータセットを用いた提案手法の評価や，クローン特性による影響の調査は今後の課題である．

% \subsection{構成妥当性}
% 構成妥当性への脅威は，コードクローンの分類の定義と測定方法の乖離である．
% 特に，演算子を抽象化の対象から除外した判断は，既存のツールや先行研究のType2の定義と一部異なる可能性がある．
% しかし，3章で述べた通り，演算子はプログラムの計算論理の核心をなす要素であり，
% かつ AST の実装依存性を排除するためには固定的な要素として扱うことが妥当であると判断した．
% この設計方針がラベリング結果に与える影響については，実験結果の考察において詳細に検討している．

% \subsection{結論妥当性}
% 結論妥当性への脅威としては，評価に使用したクローンペアのサンプルサイズ（合計100個）が挙げられる．
% 統計的な有意性を完全に確保するには十分な数とは言えないが，本研究の主目的は提案する統一的ラベリング手法の原理的な有効性と実現可能性を示すことにあり，
% 初期評価としては適切な規模であると考える．
% 今後，より大規模かつ多様なデータセットを用いた検証が課題である．

\subsection{結論妥当性} 
結論妥当性への脅威として，評価実験におけるサンプルサイズが挙げられる．
被験者6名という規模は，統計的に十分な一般性を担保しているとは言い難い．
得られた知見（グループ分けや判断傾向）が開発者全体の一般的な傾向を代表していると断定するには，
今後，より多くの被験者を対象とした大規模な調査による検証が必要である．

\section{おわりに}

本研究では，複数のコードクローン検出ツールから得られる結果を統合し，一貫性のあるデータセットを構築するため，
コードクローン検出の後処理としての統一的ラベリング手法の提案を行なった．


提案手法の妥当性を評価するために実施した被験者実験では，以下の知見が得られた．

既存の行単位の類似度ではType4と判定されていたクローンペアに対し，
提案手法がType3と判定したケースでは，人間の感覚もType3を支持する傾向にあった．
% これは、ASTを用いることでソースコードの共通した部分を分類できることを示している．
一方で，提案手法がType4と判定したクローンペアを人間がType3と見なすケースも確認された．
% これは，特定の構文要素を一律に無視・保持する現在の分類定義が，
% 人間の感覚に対してズレがあることを示唆している．

以上の結果から，類似度という単一の指標に頼るのではなく，
構造的なアプローチによって統一的なラベルを付与する本手法の有用性が確認された．
同時に，人間の感覚により近づけるためには，分類定義のさらなる見直しが必要であるという結論に至った．
また，被験者ごとの傾向から，本研究が目的とする統一的なラベリング手法の必要性が改めて確認された．


今後の展望として，次の三つが考えられる．

一つ目は，提案手法における分類基準の最適化である．
実験で明らかになった人間との感覚のズレを解消するため，
文の種類や文脈に応じた動的なフィルタリングを導入することが考えられる．

二つ目は，提案手法を用いて統一的なラベリングが行われたデータセットの作成である．
複数の既存検出ツールから得られた結果に対し，本手法を用いて統一的なラベリングを行うことで，
ノイズの少ない高品質なデータセットの整備が可能となる．
このようなデータセットをLLMの学習データとして活用し，
クローン情報の付与がLLMのコード生成精度や理解能力の向上にどの程度寄与するかを詳細に検証することが考えられる．

三つ目は，Java以外のプログラミング言語への提案手法の拡張である．
本研究で採用した解析ライブラリであるTree-sitterは多言語共通のインターフェースを提供しており，
PythonやC++といった他言語への適用が容易であるという特長を持つ．
したがって，今後は対象言語を拡大し，異なる言語仕様においても本研究と同様のラベリング精度および一貫性が得られるかについて，
評価実験を通じて手法の汎用性を実証していく必要がある．


\acknowledgement{
    大阪大学大学院情報科学研究科コンピュータサイエンス専攻肥後芳樹教授には，研究の方向性の検討から研究活動の直接の御指導，
    論文の執筆, 発表資料の作成に至るまで，研究活動全ての場面で手厚く御指導，御助言を賜りました．
    肥後芳樹教授の適切な御指導により，研究活動を行え，研究会での発表や論文の執筆をすることができました．
    心より深く感謝申し上げます．

    I would like to express my deepest gratitude to Professor Kula Gaikovina Raula from the Department
    of Computer Science, Graduate School of Information Science and Technology, Osaka
    University, for his invaluable advice during presentations within our laboratory.

    I would like to express my deepest gratitude to Assistant Professor Olivier Nourry from the Department
    of Computer Science, Graduate School of Information Science and Technology, Osaka
    University, for his invaluable advice during presentations within our laboratory.

    大阪大学大学院情報科学研究科コンピュータサイエンス専攻松下誠准教授には，研究室内の発表機会にて貴重なご意見，ご助言賜りました．

    大阪大学大学院情報科学研究科コンピュータサイエンス専攻楠本真二教授には，研究室内の発表機会にて貴重なご意見，ご助言賜りました．

    大阪大学大学院情報科学研究科コンピュータサイエンス専攻\UTF{67D7}本真佑准教授には，研究室内の発表機会にて貴重なご意見，ご助言賜りました．

    事務職員軽部瑞穂氏，宮崎貴羅氏は研究活動に関わらず，多くのサポートをしていただきました．

    最後に，大阪大学大学院情報科学研究科コンピュータサイエンス専攻肥後研究室のメンバーには，
    被験者実験の参加や普段の日常生活において，様々な場面で助けられました．心より深く感謝申し上げます．
}

% 参考文献を出力
\bibliographystyle{jplain}
\bibliography{reference}

% \section{付録}
% \begin{table}[hb]
% \centering
% \caption{Tree-sitterにおいて単文として定義するノードと役割}
% \label{tab:statement_nodes}
% \begin{tabular}{lp{10cm}} 
% \hline
% \textbf{ノード} & \textbf{説明} \\ \hline
% expression\_statement & 式(代入，メソッド呼び出し，インクリメント等)を文として完結させたノード \\
% local\_variable\_declaration & メソッド内でローカル変数を宣言する文, 型と識別子を保持するノード\\
% declaration & クラス，インタフェース，またはフィールド等の宣言全般を指す広義のノード \\
% return\_statement & メソッドの実行を終了し，呼び出し元へ値を返す制御文 \\
% throw\_statement & 例外を明示的にスローし，通常の実行フローを中断する文 \\
% break\_statement & ループ(for, while等)やswitchブロックから直ちに脱出するための制御文 \\
% continue\_statement & ループの現在の反復を終了し，次の反復処理へスキップするための文 \\
% yield\_statement & switch式において，値を返してブロックを終了するための文(Java 13以降) \\
% assert\_statement & プログラムの前提条件を検証するための表明文. デバッグや検証に用いられる.  \\ \hline
% \end{tabular}
% \end{table}

\end{document}
