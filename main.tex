\documentclass[11pt]{ist-thesis}
% \pagestyle{bachelorthesis}  % 卒論
%\pagestyle{ebachelorthesis}  % Graduation Thesis
\pagestyle{masterthesis}  % 修論（目安;38ページ以上）
% \pagestyle{emasterthesis}  % Master Thesis
%\pagestyle{draft}  % 未完成ドラフト
%\pagestyle{edraft}  % Draft

\usepackage{listings}
\usepackage{xcolor}
\usepackage[dvipdfmx]{graphicx}
\usepackage{subcaption}
\usepackage{multirow}

% 言語ごとのスタイル設定
\lstset{
    language=Java,                  % 言語指定
    basicstyle=\small\ttfamily,     % 基本フォント
    keywordstyle=\color{blue},      % 予約語の色
    commentstyle=\color{green!60!black}, % コメントの色
    stringstyle=\color{orange},     % 文字列の色
    numbers=left,                   % 行番号を左に表示
    numberstyle=\tiny\color{gray},  % 行番号のスタイル
    frame=single,                   % 枠線
    breaklines=true,                % 長い行の自動折り返し
    captionpos=b                    % キャプションを下に配置
}

\title{コードクローン検出の後処理としての統一的ラベリング手法}
\author{清水 ささら}
\supervisor{肥後 芳樹 教授}
%\supervisor{Professor Yoshiki Higo}
\deadline{令和8年2月2日} % 正規の提出期日
%\deadline{February Xth, XXXX}

\begin{document}

\titlepage

% タイトル中に改行が含まれる場合は，改行を取り除いたタイトルを再定義
\title{コードクローン検出の後処理としての統一的ラベリング手法}

\abstract{
ここに概要を書く

% 種々のコードクローン検出ツールが提案されているが，それぞれが独自のコードクローンの定義に基づいて検出を行っている．コードクローンは類似度に応じて Type-1，Type-2，Type-3，Type-4 の4種類に分類されるが，これらの定義は必ずしも厳密ではなく，特に Type-3 と Type-4 の境界は曖昧である．その結果，ある検出ツールでは Type-3 として検出されたコードクローンが，別の検出ツールでは Type-4 として扱われるといった不整合が生じる．また，多くのコードクローン検出ツールは検出のみを行い，クローンのカテゴリに関するラベル付けを行わないため，検出結果の解釈や比較が困難であるという問題もある．本研究では，これらの課題を解決するために，コードクローン検出後の後処理として統一的なラベリング手法を提案する．提案手法を用いることで，使用するコードクローン検出ツールに依存することなく，検出されたコードクローンに対して一貫した基準に基づくラベリングが可能となる．近年，ソフトウェア工学分野ではコードクローン情報を大規模言語モデル（LLM）の学習データとして利用する研究が増加しており，本研究で提案するラベリング手法は，高品質にラベル付けされたコードクローンデータの構築にも寄与する．提案手法の有効性を評価するため，広く利用されているコードクローンデータセットである BigCloneBench に含まれるコードクローンを対象に再ラベリングを行った．そして，BigCloneBench における既存のラベリングと提案手法によるラベリングについて被験者実験を実施し，どちらがコードクローンの定義により適合しているかを比較・分析した．
}

\keyword{
  \hspace{7mm} 論文のキーワードその1\\
  \hspace{7mm} 論文のキーワードその2\\
  \hspace{7mm} 論文のキーワードその3\\
}

% 目次を出力
\toc

% 本文開始
% \section{1章タイトル}
% 1章本文
% \subsection{1.1節タイトル}
% 1.1節本文
% \subsubsection{1.1.1項タイトル}
% 1.1.1項本文

\section{はじめに}

\section{準備}

\subsection{コードクローン}
% Type分類について
コードクローンとは，プログラムテキスト中の一致または類似するコード片である~\cite{Inoue2001}. 
コードクローンにバグが含まれているとバグの修正漏れを引き起こす原因になり，ソースコードの保守性が低下する要因の一つとなる~\cite{Roy2007}．
また，互いにクローン関係であるソースコード片のペアを，クローンペアと呼ぶ．

一般にコードクローンは，構文的な類似度に基づき，以下の4種類に分類される~\cite{Roy2009}．

\begin{description}
    \item[Type1] 改行，コメント，空白を除いて一致
    \item[Type2] Type1に加えて，リテラル，識別子，型の違いを除いて一致 
    \item[Type3] Type2に加えて，文の挿入，削除，変更を除いて一致
    \item[Type4] 構文は異なるが同じ機能を提供する
\end{description}

% テキスト
% Nicad~\cite{Nicad}あり
% トークン
% NIL~\cite{NIL}あり
% CCFinder~\cite{KamiyaTSE2002}なし
% SoucererCC~\cite{SourcererCC}あり
% LVMapper~\cite{LVMapper}なし
% AST
% Deckard~\cite{Jiang2007}あり
% Yang~\cite{YandCOMPSAC2018}なし
% グラフ
% CFG
% StoneDetector~\cite{StoneDetector}なし
% GroupDriod~\cite{GroupDroid}異色なし
% PDG
% CCGraph~\cite{CCGraph}なし

\subsection{コードクローン検出ツール}

ソースコードの規模が大きくなると，ソースコード中のコードクローンの量も増加するため，手動でコードクローンを管理することは困難となる．
そのため，ソースコード中から自動的にコードクローンを検出するツールが研究されている~\cite{Jiang2007,KamiyaTSE2002,Nicad}．
それぞれのツールについて表~\ref{tab:tool_comparison}に示す．
表~\ref{tab:tool_comparison}では，コードクローン検出のための手法と，ツールがコードクローンを検出する際，Type分類のラベルを出力するか否かを示す．
% 2.1節の定義において，Type3とType4の境界は曖昧である．
コードクローン検出ツールはそれぞれ独自の中間表現(抽象構文木，依存グラフ，トークン列など)や類似度計算アルゴリズムを用いているため，
同じソースコードからコードクローンを検出する場合でも検出されるコードクローンが異なったり，同じ箇所がコードクローンとして検出された場合でもその分類が異なったりする．
また，コードクローン検出ツールには，検出のみを行い，分類を行わないツールも存在する．


\begin{table}[!b]
\centering
\caption{既存のコードクローン検出ツール}
\label{tab:tool_comparison}
\begin{tabular}{lllc}\hline
手法 &  & ツール名/著者名 & ラベルの有無 \\ \hline
テキストベース &  & Nicad~\cite{Nicad} & あり \\ 
\multirow{3}{*}{トークンベース} &  & NIL~\cite{NIL} & あり \\ \hline
 & & CCFinder~\cite{KamiyaTSE2002} & なし \\
 & & SoucererCC~\cite{SourcererCC} & あり \\
 & & LVMapper~\cite{LVMapper} & なし \\ \hline
\multirow{1}{*}{抽象構文木ベース} &  & Deckard~\cite{Jiang2007} & あり \\ \hline
\multirow{4}{*}{グラフ} & \multirow{3}{*}{CFGベース}& Yang~\cite{YandCOMPSAC2018} & なし \\
 &  & StoneDetector~\cite{StoneDetector} & なし \\
 & & GroupDroid~\cite{GroupDroid} & なし \\ 
 & PDGベース & CCGraph~\cite{CCGraph} & なし \\ \hline
\end{tabular}
\end{table}

機械学習ツール~\cite{ZhangICSE2019,Feng2020,BuiICSE2021,LiICSME2017,Saini2018,Zhao2018,Li2025}
学習にBigCloneBench~\cite{li2025}
評価~\cite{Zhao2018}






\subsection{BigCloneBench}
% 既存の大規模なベンチマークとその問題点
BigCloneBenchは，コードクローン検出器の性能評価で用いられるJavaの大規模なベンチマークである~\cite{BigCloneBench}．
複数のソフトウェアプロジェクトから収集した大規模データセットIJDataset2.0から，特定の機能を実装している可能性のあるソースコードを自動で特定し，
対象の機能を正しく実装しているか否かのタグ付が手動で行われている．

BigCloneBenchでは，Type1，Type2のコードクローンは，ソースコードの正規化後テキストが一致するかで判定している．
それらに属さない，Type3及びType4のコードクローンは，行単位での構文的類似度に基づいて0以上1未満の範囲で，次のように分類される．
この構文的類似度は，行の一致する割合で求められる．

\begin{description}
    \item[Strongly-Type3] 0.7以上1.0未満
    \item[Moderately-Type3] 0.5以上0.7未満
    \item[Weakly-Type3] 0.0以上0.5未満
\end{description}

コードクローン検出ツールの研究において，Weakly-Type3クローンはType4クローンとして用いられている~\cite{AlamICSME2025,PinkuICSME2024,WangICSE2023,YuICSE2025,ZhangICCQ2024}．
また，機械学習を用いたコードクローン検出手法において，BigCloneBenchは学習データとして用いられている\cite{WangICSE2023,YuICSE2025}．
しかし，BigCloneBenchはタグ付けが不正確で，Type4コードクローンのデータとして扱うには不適切であることがいわれている~\cite{KrinkeIWSC2022,Krinke2025}. 
BigCloneBenchをType-4クローンの検出性能評価に用いる場合，誤ったタグ付の影響で妥当性が脅されるため，
Type-4クローンの検出を目標とする，機械学習を用いたコードクローン検出手法における評価に対する結果の信頼性が低下する．


% 検証用(評価用)データとして用いてる~\cite{ZhangICCQ2024},~\cite{AlamICSME2025},~\cite{PinkuICSME2024}
% 学習データとして用いてる~\cite{WangICSE2023},~\cite{YuICSE2025}
% harmfl~\cite{KrinkeIWSC2022}

\subsection{抽象構文木(AST)}
ASTとはソースコードの構文構造を木構造で表現したデータ構造である．
ASTにおいて，各頂点(ノード)はプログラムを構成する構文要素を表し，各辺はそれら要素間の論理的な親子関係や入れ子構造を表す．
この親子関係に基づき，ASTは階層的な構造を持つ．

以下にASTに関する用語を示す．また，図~\ref{fig:AST_discription}にソースコード例とそれに対応するASTを示す．

\begin{description}
    \item[根ノード] 親を持たないノードを指す~\cite{Fan2021ICSE}．図~\ref{fig:AST_discription}では青く示されたmethod\_declarationノードである．
    \item[葉ノード] 子を持たないノードを指す~\cite{Fan2021ICSE}．図~\ref{fig:AST_discription}では緑で示されたノードである．斜体で示されているのがそのノードの持つ値である．
\end{description}

\begin{figure}[t]
  \centering
  \includegraphics[width=0.8\textwidth]{images/AST_discription.pdf}
  \caption{ソースコード例と対応するAST}
  \label{fig:AST_discription}
\end{figure}

本研究では，AST解析ライブラリとしてTree-sitter~\footnote{https://github.com/tree-sitter/tree-sitter}を用いた．
Tree-sitterは多くのプログラミング言語に対応していることから選択した．

\section{本研究の動機}
% 前回と今回の原稿を見てずっと思っているんですが，研究の動機付けを重視していない気がする．
% なぜ独立したラベリングが必要なのが原稿にちゃんと書かれていない．
% スライドを作ったんでこれを参考にして，「本研究の動機」という独立した章を作ってもらえますか．
% そこでこのスライドの内容を自分なりにかみ砕いて記述してください．
% このスライドの通りにしなくて自分が書きやすいストーリーでいいので背景をちゃんと説明してください．
% もちろん図を使って．どんなに長くなってもいいのでちゃんとした説明を入れてください

あるソースコードに含まれるコードクローンを検出するため，現在では様々なコードクローン検出ツールが存在する．
現状では，それらのツールは様々なソースコードに対して単一で用いられコードクローンの検出を行っている(図~\ref{fig:motivation_1})．
各コードクローン検出ツールは，異なるアルゴリズムを利用してコードクローン検出を行う．
例えば，CCFinder~\cite{KamiyaTSE2002}，NIL~\cite{NIL}はトークンベース，Nicad~\cite{Nicad}はテキストベースの検出器である．
単一のコードクローン検出ツールを用いた検出では，偏りがあり，検出したいコードクローンを全て検出できるわけではない．

\begin{figure}[t]
  \centering
  \includegraphics[width=0.5\textwidth]{images/motivation_fig1.pdf}
  \caption{コードクローン検出の現状}
  \label{fig:motivation_1}
\end{figure}

検出されるコードクローンの偏りを軽減するため，複数の検出ツールを対象ソースコードに実行することが考えられる(図~\ref{fig:motivation_2})．
複数のツールを実行することで可能な限り多様なコードクローンの検出を試みることが考えられる．
しかし，各ツールにおけるコードクローンの定義が異なるため，検出後にどのTypeに分類されるかのラベリング結果が統一されない問題が起こる．
例えば，ある関数Aとある関数Bがツール1によってType3として検出された場合に，別のツール2では，Type4として検出される場合がある．
また，コードクローンの大規模データベース作成の際にも，この問題が発生する．
ツールごとにラベリング結果が異なるため，データの統合ができない．
さらには，コードクローンの検出は行うものの，ラベリングを行わないツールも存在する．
そのため，複数のクローン検出結果をそのラベリングも含めて単一のデータセットとして扱うことはできない．

\begin{figure}[t]
  \centering
  \includegraphics[width=0.8\textwidth]{images/motivation_fig2.pdf}
  \caption{コードクローン検出の問題}
  \label{fig:motivation_2}
\end{figure}

この問題を解決するため，提案手法では，コードクローン検出の後処理としての統一的なラベリングを行う(図~\ref{fig:motivation_3})．
これにより，複数ツールから検出されたコードクローンに一貫した分類に基づいたラベリングを行うことができる．
統一的なラベリングを行うことで，それぞれのツールの検出結果を単一のデータセットに統合することが可能となる．
これにより，コードクローン情報の質が向上し，コードクローンデータを他の研究や開発に利用しやすくなる．
例えば，LLMの学習用データとしての利用が挙げられ，LLMベースの超高精度なクローン検出の実現が見込まれる．

\begin{figure}[t]
  \centering
  \includegraphics[width=1\textwidth]{images/motivation_fig3.pdf}
  \caption{提案手法による解決策}
  \label{fig:motivation_3}
\end{figure}

コードクローン検出後の処理に限定したのは，実行時間の問題からである．
対象関数の数を$n$とした場合，提案手法の実行回数は$n^2$となる．
提案手法では，抽象構文木を用いて分類を行っており，二つの木を比較すること自体が非常に重い処理である．
全ての関数のペアの比較して結果を得ることは時間的に現実的ではない．
また，提案手法は入力をクローンペアと想定しているため，一定以上の差異がある場合にType4として判定している．
そのため，提案手法はクローンペアではない関数のペアが与えられた場合にそれがクローンペアではないのか，もしくはType4クローンなのかが判定できない．
これらのことから，提案手法ではコードクローン検出後に限定した統一的なラベリングを行う．



\section{提案手法}
本節では，本研究で提案するコードクローン検出の後処理としての統一的なラベリング手法について述べる．
% 図~\ref{fig:sub_a}に示すように，従来のコードクローン分析では，特定のツールの検出結果をそのまま利用する．
% そのため，ツールによってラベルが異なる，あるいは，出力にラベルを含まれないという課題が発生する．
% これは，ツール間の比較や，機械学習への高精度な学習データの提供を困難にする．

% しかし，図~\ref{fig:sub_b}に示すように，コードクローン検出ツールによって，コードクローン検出ののち，
% 提案手法によって統一された基準基づいたラベリングを行うことで，ツールによらないラベルが得られ，ツール間の比較や機械学習への高精度な学習データの提供が可能となる．

% \begin{figure}[t]
%     \centering
%     % 上の図 (a)
%     \begin{subfigure}{\textwidth}
%         \centering
%         \includegraphics[width=0.6\textwidth]{images/flow_before.pdf}
%         \caption{従来の流れ}
%         \label{fig:sub_a}
%     \end{subfigure}
    
%     \vspace{1cm} % 図と図の間の垂直方向の隙間を調整
    
%     % 下の図 (b)
%     \begin{subfigure}{\textwidth}
%         \centering
%         \includegraphics[width=0.9\textwidth]{images/flow_after.pdf}
%         \caption{提案手法を用いた場合の流れ}
%         \label{fig:sub_b}
%     \end{subfigure}
    
%     \caption{従来の方法と提案手法を用いた場合の違い}
%     \label{fig:ast_comparison}
% \end{figure}



\subsection{分類基準}

本研究ではASTに基づいて新たな分類基準を定義した．
定義は以下の通りである．
すでにコードクローンとして検出されたコードが対象で，
与えられたクローンペアをそれぞれASTに変換し，二つのASTの差に応じて分類を行う．

\begin{description}
    \item[Type1] ASTが完全一致
    \item[Type2] 演算子以外の葉ノードを除いてASTが一致 
    \item[Type3] 葉ノードに加え，単文以下のノードを除いてASTが一致
    \item[Type4] 上記に分類されないもの
\end{description}

Type1〜3の分類基準について詳細を述べる．

Type1では葉ノードの持つ値を含むAST全体が完全に一致する(図~\ref{fig:AST_type1})．
ASTの木の形状と，斜体で示された値が完全に同一である場合，Type1と判断される．

\begin{figure}[t]
  \centering
  \includegraphics[width=0.8\textwidth]{images/ast_type1.pdf}
  \caption{Type1の例}
  \label{fig:AST_type1}
\end{figure}

Type2では演算子以外の葉ノードを除いたASTが一致する．
% 本研究では，2.1節で示したコードクローン研究における標準的な定義に従い，演算子を構文構造の一部として扱うため，演算子を葉ノードから除いた．
ASTにおける演算子の表現形式はパーサの実装仕様に強く依存する．
例えば，一部のパーサでは演算子が二項演算ノードの下位に独立した葉ノードとして定義されるが，
別のパーサではノード自体の属性値として保持される．
実装の差異が存在するため，本手法では，演算子を葉ノードから除いた．
図~\ref{fig:AST_type2}に示した例では，赤く示した部分がソースコード上で異なる部分である．
葉ノードとして除かれるノードを灰色で，比較対象として残るノードを黒で示している．
黒く示されたノードを持つASTの形状が同一であるため，Type2と判断される．


\begin{figure}[t]
  \centering
  \includegraphics[width=0.8\textwidth]{images/ast_type2.pdf}
  \caption{Type2の例}
  \label{fig:AST_type2}
\end{figure}

Type3では単文以下のノードを除いたASTが一致する．
% 単文として定義するノードを表~\ref{tab:statement_nodes}示す．これらはTree-sitterで用いられるノードで定義される．これらのノードを親ノードとして持つノードもType3では除かれる．
Javaにおいて，単文として定義される文を表~\ref{tab:statement_java}に示す．
図~\ref{fig:AST_type3}に示した例では，Type2の例に加え，return\_statementノードが単文にあたるため，
それ以下のノードが除かれる．黒く示されたノードを持つASTの形状が同一であるため，Type3と判断される．

\begin{table}[!b]
\centering
\caption{Javaにおいて単文として定義される文の例}
\label{tab:statement_java}
\begin{tabular}{lp{10cm}} 
\hline
\textbf{単文} & \textbf{例} \\ \hline
\multirow{2}{*}{式文} & x = a + b; \\
 & System.out.println(s);\\
変数宣言文 & int count = 0; \\
return文 & return result; \\
throw文 & throw new IllegalArgumentException(); \\
break文 & break; \\
continue文 & continue; \\
yield文 & yield 100; \\
assert文 & assert list != null;  \\ \hline
\end{tabular}
\end{table}


\begin{figure}[ht]
  \centering
  \includegraphics[width=0.8\textwidth]{images/ast_type3.pdf}
  \caption{Type3の例}
  \label{fig:AST_type3}
\end{figure}

% \begin{table}[hb]
% \centering
% \caption{単文として定義するノードと役割}
% \label{tab:statement_nodes}
% \begin{tabular}{lp{10cm}} 
% \hline
% \textbf{ノード} & \textbf{説明} \\ \hline
% expression\_statement & 式(代入，メソッド呼び出し，インクリメント等)を文として完結させたもの \\
% local\_variable\_declaration & メソッド内でローカル変数を宣言する文, 型と識別子を保持する\\
% declaration & クラス，インタフェース，またはフィールド等の宣言全般を指す広義のノード \\
% return\_statement & メソッドの実行を終了し，呼び出し元へ値を返す制御文 \\
% throw\_statement & 例外を明示的にスローし，通常の実行フローを中断する文 \\
% break\_statement & ループ(for, while等)やswitchブロックから直ちに脱出するための制御文 \\
% continue\_statement & ループの現在の反復を終了し，次の反復処理へスキップするための文 \\
% yield\_statement & switch式において，値を返してブロックを終了するための文(Java 13以降) \\
% assert\_statement & プログラムの前提条件を検証するための表明文. デバッグや検証に用いられる.  \\ \hline
% \end{tabular}
% \end{table}




\section{評価実験}
本節では，評価実験について述べる．
本実験は，BigCloneBenchが行単位での構文的類似度に基づいて分類した場合と．提案手法で分類した場合のどちらがより人間の感覚に近いのかを評価することを目的としている．
特に，分類の基準が明確でないType3, Type4のコードクローンを対象とする．

\subsection{実験対象データセット}

% \subsection{BigCloneBenchの分類結果}
実験対象データセットとしてBigCloneBenchを用いた．
提案手法を用いてBigCloneBench内のクローンペアの分類を行った結果を表~\ref{tab:BCB_type}に示す．

\begin{table}[!b]
\centering
\caption{提案手法によるBigCloneBenchの分類結果}
\label{tab:BCB_type}
\begin{tabular}{ccrrrrr}
\hline
 & & Type1 & Type2 & Strongly-Type3 & Moderately-Type3 & Weakly-Type3 \\ \hline
\multirow{4}{*}{提案手法} & Type1 & 48,116 & 0 & 0 & 0 & 0 \\
& Type2 & 0 & 4,234 & 3,637 & 12  & 1  \\
& Type3 & 0 & 0 & 7,984 & 13,302 & 46,973  \\
& Type4 & 0 & 0 & 10,345 & 74,992 & 8,403,230 \\ \hline
& 合計 & 48,116 & 4,234 & 21,966 & 88,306 & 8,450,204 \\ \hline
\end{tabular}
\end{table}

% BigCloneBenchのStrongly-Type3，Moderately-Type3，Weakly-Type3に分類されるクローンペアのうち，提案手法でType2と判断されたクローンペアの例をListing~\ref{code:type２}に示す．修飾子が異なるため，BigCloneBenchではModerately-Type3に分類されていた．


% \begin{lstlisting}[caption={Type2と判断されたクローンペアの例}, label={code:type２}]
% // --- id 4644121 ---
% protected void copy (Reader reader, OutputStream outputs) throws IOException {
%     IOUtils.copy (reader, outputs);
% }

% // --- id 11088627 ---
% public static void copyWithoutClose (InputStream is, OutputStream os) throws IOException {
%     IOUtils.copy (is, os);
%     }
% \end{lstlisting}


\subsection{実験手順}
被験者はコンピュータサイエンスを専攻する博士前期課程の大学院生6人であり，いずれもJavaを用いたプログラミングの経験がある．
以下のいずれかの基準を満たすクローンペアを本研究の調査対象とした．

\begin{itemize}
    \item Strongly-Type3に分類されるクローンペアのうち提案手法でType4と分類されたクローンペア
    \item Weakly-Type3に分類されるクローンペアのうち提案手法でType3と分類されたクローンペア
\end{itemize}

BigCloneBenchに含まれるクローンペアは，いずれもメソッド単位のコード片から構成される．
同一のメソッドが複数のペアに含まれる場合は，そのうち一組のみを抽出対象とした．
ペアを構成する二つのメソッドの合計トークン数が少ない順にそれぞれ50個，合計100個のクローンペアを対象とした．
被験者には，事前に，2.1節に記述したコードクローン分類の定義を提示し，100個のクローンペアがどちらに分類されるべきかを判断してもらった．
また，判断理由についても回答してもらった．

\section{実験結果と考察}

\section{妥当性への脅威}
% 本研究では，Tree-sitterを用いてASTを作成し，Tree-sitterの定めるノードを基準とし分類を行った．
% したがって，Tree-sitterの性能に依存する．

\section{おわりに}


% 参考文献を参照する\cite{KamiyaTSE2002}

\acknowledgement{
}

% 参考文献を出力
\bibliographystyle{jplain}
\bibliography{reference}

\end{document}
