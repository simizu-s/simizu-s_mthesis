\documentclass[11pt]{ist-thesis}
% \pagestyle{bachelorthesis}  % 卒論
%\pagestyle{ebachelorthesis}  % Graduation Thesis
\pagestyle{masterthesis}  % 修論（目安;38ページ以上）
% \pagestyle{emasterthesis}  % Master Thesis
%\pagestyle{draft}  % 未完成ドラフト
%\pagestyle{edraft}  % Draft

\usepackage{listings}
\usepackage{xcolor}
\usepackage[dvipdfmx]{graphicx}
\usepackage{subcaption}
\usepackage{multirow}

% 言語ごとのスタイル設定
\lstset{
    language=Java,                  % 言語指定
    basicstyle=\small\ttfamily,     % 基本フォント
    keywordstyle=\color{blue},      % 予約語の色
    commentstyle=\color{green!60!black}, % コメントの色
    stringstyle=\color{orange},     % 文字列の色
    numbers=left,                   % 行番号を左に表示
    numberstyle=\tiny\color{gray},  % 行番号のスタイル
    frame=lines,                  % 枠線
    breaklines=true,                % 長い行の自動折り返し
    captionpos=b                    % キャプションを下に配置
}

% キャプションの名前を「Listing」から「ソースコード」に変更
\renewcommand{\lstlistingname}{ソースコード}
\definecolor{highlightorange}{RGB}{255, 200, 100} % 少し薄めのオレンジを指定

\title{コードクローン検出の後処理としての統一的ラベリング手法}
\author{清水 ささら}
\supervisor{肥後 芳樹 教授}
%\supervisor{Professor Yoshiki Higo}
\deadline{令和8年2月2日} % 正規の提出期日
%\deadline{February Xth, XXXX}

\begin{document}

\titlepage

% タイトル中に改行が含まれる場合は，改行を取り除いたタイトルを再定義
\title{コードクローン検出の後処理としての統一的ラベリング手法}

\abstract{
コードクローンはソースコード中に存在する，一致または類似するコード片であり，バグの修正漏れを引き起こす原因となる．
種々のコードクローン検出ツールが提案されているが，それぞれが独自の手法を用いて検出を行っている．
コードクローンは類似度に応じてType1，Type2，Type3，Type4の4種類に分類されるが，これらの定義は必ずしも厳密ではなく，
特にType3とType4の境界は曖昧である．
その結果，ある検出ツールではType3として検出されたコードクローンが，別の検出ツールではType4として扱われるといった不整合が生じる．
また，多くのコードクローン検出ツールは検出のみを行い，クローンのカテゴリに関するラベル付けを行わないため，検出結果の解釈や比較が困難であるという問題もある．

本研究では，これらの課題を解決するために，コードクローン検出後の後処理として統一的なラベリング手法を提案する．
提案手法を用いることで，使用するコードクローン検出ツールに依存することなく，検出されたコードクローンに対して一貫した基準に基づくラベリングが可能となる．
近年，ソフトウェア工学分野ではコードクローン情報を大規模言語モデル（LLM）の学習データとして利用する研究が増加しており，
本研究で提案するラベリング手法は，高品質にラベル付けされたコードクローンデータの構築にも寄与する．
提案手法の有効性を評価するため，広く利用されているコードクローンデータセットであるBigCloneBenchに含まれるコードクローンを対象に再ラベリングを行った．
そして，BigCloneBench における既存のラベリングと提案手法によるラベリングについて被験者実験を実施し，どちらがコードクローンの定義により適合しているかを比較・分析した．
}

\keyword{
  \hspace{7mm} コードクローン\\
  \hspace{7mm} BigCloneBench\\
  \hspace{7mm} 抽象構文木\\
}

% 目次を出力
\toc

% 本文開始
% \section{1章タイトル}
% 1章本文
% \subsection{1.1節タイトル}
% 1.1節本文
% \subsubsection{1.1.1項タイトル}
% 1.1.1項本文

\section{はじめに}

コードクローンとは，プログラムテキスト中の一致または類似するコード片である~\cite{Inoue2001}.
コードクローンにバグが含まれているとバグの修正漏れを引き起こす原因になり，ソースコードの保守性が低下する要因の一つとなる~\cite{Roy2007}．
コードクローンは，構文的な類似度に基づいてType1，Type2，Type3，Type4の4種類に分類される~\cite{Roy2009}．
ソースコードの規模が大きくなると，手動でコードクローンを管理することは困難となる．
そのため，コードクローンを自動で検出するツールの研究が行われている．

現状では，ソースコード中のコードクローン検出は，単一のツールを用いて行われる．
様々なコードクローン検出ツールが存在するが，それらは，検出する際に用いる中間表現や計算アルゴリズムが異なる．
例えば，NiCad~\cite{Nicad}は行単位での検出，
CCFinder~\cite{KamiyaTSE2002}，NIL~\cite{NIL}は字句単位での検出を行う．
単一のコードクローン検出ツールを用いた検出では，ソースコードから検出できるコードクローンに偏りが生じる．
この課題解決のため，一つのソースコードに対し
複数のコードクローン検出ツールを実行することが考えられる．
複数のツールのを利用することで可能な限りコードクローンを検出する．
しかし，各ツールは，分類の基準が異なるため，コードクローンとして検出されたコードに対して異なるラベリングを行う場合がある．
また，ツールによっては，コードクローンの検出は行うものの，分類は行わないツールも存在する．
ラベリング結果が異なることや，ラベリングが行われないことは，複数ツールから得られたクローン検出結果を用いて
大規模なコードクローンのデータベースを作成する際に，単一のデータセットとして統合ができないという問題が発生する．


この問題解決のため，本論文では，コードクローン検出後の後処理として統一的なラベリング手法を提案する．
提案手法では，抽象構文木を用いて，コードクローンの分類を行う．
% 抽象構文木の持つノードの種類によって分類を行い，
提案手法を用いることで，複数の検出ツールから検出されたコードクローンに対し，統一されたラベリングを行うことができる．
統一的なラベリングが行われたコードクローンは単一のデータセットに統合が可能となり，コードクローンデータを他の研究や開発に利用しやすくなる．

本研究では，評価実験として被験者実験を行った．

以降，2章では，本研究で用いる技術について述べる．
3章では，本研究の動機について述べる．
4章では，提案手法の詳細について述べる．
5章では，評価実験の詳細について述べ，6章でその結果と考察を述べる．
7章では，妥当性の脅威を述べ，8章では，まとめと今後の課題について述べる．


% \textcolor{blue}{




\section{準備}

\subsection{コードクローン}
% Type分類について
コードクローンとは，プログラムテキスト中の一致または類似するコード片である~\cite{Inoue2001}. 
コピーとペーストによるプログラミングや，意図的に同一の処理を繰り返して書くことにより発生する．
複数のコードクローンがソフトウェアプログラム中に存在した場合，あるコードクローン上にバグが見つかると，
他のコードクローンにもバグが含まれる可能性が出てくる．
そのため，開発者は，全てのコードクローンを追跡する必要がある．
これは，バグの修正漏れを引き起こす原因になり，ソースコードの保守性が低下する要因の一つとなる~\cite{Roy2007}．
また，互いにクローン関係であるソースコード片のペアを，クローンペアと呼ぶ．

一般にコードクローンは，構文的な類似度に基づき，以下の4種類に分類される~\cite{Roy2009}．

\begin{description}
    \item[Type1] 改行，コメント，空白を除いて一致するコードクローン
    \item[Type2] Type1に加えて，リテラル，識別子，型の違いを除いて一致するコードクローン
    \item[Type3] Type2に加えて，文の挿入，削除，変更を除いて一致するコードクローン
    \item[Type4] 構文は異なるが同じ機能を提供するコードクローン
\end{description}

上記のType3，Type4の境界は曖昧であるため，コードクローン検出ツールによって分類の基準が異なる．

% テキスト
% Nicad~\cite{Nicad}あり
% トークン
% NIL~\cite{NIL}あり
% CCFinder~\cite{KamiyaTSE2002}なし
% SoucererCC~\cite{SourcererCC}あり
% LVMapper~\cite{LVMapper}なし
% AST
% Deckard~\cite{Jiang2007}あり
% Yang~\cite{YandCOMPSAC2018}なし
% グラフ
% CFG
% StoneDetector~\cite{StoneDetector}なし
% GroupDriod~\cite{GroupDroid}異色なし
% PDG
% CCGraph~\cite{CCGraph}なし

\subsection{コードクローン検出ツール}

ソースコードの規模が大きくなると，ソースコード中のコードクローンの量も増加するため，手動でコードクローンを管理することは困難となる．
そのため，ソースコード中から自動的にコードクローンを検出するツールが研究されている
~\cite{StoneDetector,iClones,Jiang2007,KamiyaTSE2002,GroupDroid,NIL,Nicad,SourcererCC,YandCOMPSAC2018,CCGraph}．

% 1. 行単位および字句単位の手法
行単位の手法として代表的なNiCad~\cite{Nicad}は，ソースコードの整形と正規化を行う．
行の一致率を見ることでコードクローンの検出が可能であり，
Type1からType3までのラベリングが可能な点が特徴である．

字句単位の手法は，ソースコードをトークン列に変換して比較を行う．
CCFinder~\cite{KamiyaTSE2002}やiClones~\cite{iClones}，LVMapper~\cite{LVMapper}は
大規模なプロジェクトから高速にクローンを抽出することに長けているが，
出力結果はコードクローンがどこに含まれるかの情報のみであり，クローンタイプのラベリングは行われない．
一方で，NIL~\cite{NIL}やSourcererCC~\cite{SourcererCC}は，
トークンの類似度計算に基づいたラベリング機能を備えている．

% 2. 構文構造（AST）単位の手法
抽象構文木を利用する手法は，ソースコードを構文解析して木構造を構築し，その構造的類似度を比較する．
Deckard~\cite{Jiang2007}は，抽象構文木のサブツリーを多次元ベクトルへと変換し，LSH(Locality Sensitive Hashing)
を用いることで，文の挿入・削除を伴うType3クローンを効率的に検出する．
この手法は構文的な根拠に基づいた比較を行うため，クローンタイプに応じたラベリングが可能である．

% 3. グラフ単位の手法
プログラム依存グラフ（PDG）や制御フローグラフ（CFG）を利用するグラフ単位の手法は，
Type4検出を主な目的とする．
Yangらの手法~\cite{YandCOMPSAC2018}，StoneDetector~\cite{StoneDetector}，GroupDroid~\cite{GroupDroid}，CCGraph~\cite{CCGraph}などがこれに該当する．
これらの手法は，制御フローの構造が共通していればクローンとみなすため高度な解析が可能である一方，
同型判定アルゴリズムに伴う高い計算コストが課題となる．
また，これらのツールは，機能の等価性に焦点を当てているため，
Type1〜3といった構文的なカテゴリへの詳細なラベリングまでは行わない．

% まとめと本研究の立ち位置
% 以上の通り、多くの検出ツール（特に字句ベースやグラフベース）は、クローンの抽出能力には優れているものの、検出結果に対して標準的なラベル（Type-1〜4）を付与する機能を持っていない。このことが、異なるツール間での結果の統合や、機械学習用の高品質なデータセット構築を困難にする要因となっている。本研究が提案する**「後処理としての統一的ラベリング手法」**は、これら既存ツールの出力結果を入力とし、一貫した基準でラベルを再付与することで、既存のクローン情報の利用価値を向上させるものである。

それぞれのツールについて表~\ref{tab:tool_comparison}に示す．
表~\ref{tab:tool_comparison}では，コードクローン検出のための手法と，ツールがコードクローンを検出する際，Type分類のラベルを出力するか否かを示す．
% 2.1節の定義において，Type3とType4の境界は曖昧である．
コードクローン検出ツールはそれぞれ独自の中間表現(抽象構文木，グラフ，トークン列など)や類似度計算アルゴリズムを用いているため，
同じソースコードからコードクローンを検出する場合でも検出されるコードクローンが異なったり，同じ箇所がコードクローンとして検出された場合でもその分類が異なったりする．
また，コードクローン検出ツールには，検出のみを行い，分類を行わないツールも存在する．


\begin{table}[!b]
\centering
\caption{既存のコードクローン検出ツール}
\label{tab:tool_comparison}
\begin{tabular}{llc}\hline
手法 & ツール名/著者名 & ラベルの有無 \\ \hline
行単位での検出 &  Nicad~\cite{Nicad} & あり \\ \hline
\multirow{5}{*}{字句単位での検出} & NIL~\cite{NIL} & あり \\ 
 & CCFinder~\cite{KamiyaTSE2002} & なし \\
 & iClones~\cite{iClones} & なし \\
 & SoucererCC~\cite{SourcererCC} & あり \\
 & LVMapper~\cite{LVMapper} & なし \\ \hline
\multirow{1}{*}{抽象構文木を用いた検出} & Deckard~\cite{Jiang2007} & あり \\ \hline
\multirow{4}{*}{グラフを用いた検出} & Yang~\cite{YandCOMPSAC2018} & なし \\
 & StoneDetector~\cite{StoneDetector} & なし \\
 & GroupDroid~\cite{GroupDroid} & なし \\ 
 & CCGraph~\cite{CCGraph} & なし \\ \hline
\end{tabular}
\end{table}

表~\ref{tab:tool_comparison}に示したコードクローン検出ツールの他に，機械学習を用いたコードクローン検出手法も存在する~\cite{BuiICSE2021,Feng2020,Li2025,LiICSME2017,Saini2018,ZhangICSE2019,Zhao2018}．

% 機械学習ツール~\cite{BuiICSE2021,Li2025,LiICSME2017,Saini2018,ZhangICSE2019,Zhao2018}
% 学習にBigCloneBench~\cite{Li2025,LiICSME2017,ZhangICSE2019}
% 評価~\cite{Zhao2018,Saini2018,BuiICSE2021}
% ,Feng2020 CodeBERT







\subsection{BigCloneBench}
% 既存の大規模なベンチマークとその問題点
BigCloneBenchは，コードクローン検出器の性能評価で用いられるJavaの大規模なベンチマークである~\cite{BigCloneBench}．
複数のソフトウェアプロジェクトから収集した大規模データセットIJDataset2.0から，特定の機能を実装している可能性のあるソースコードを自動で特定し，
対象の機能を正しく実装しているか否かのタグ付けが手動で行われている．

BigCloneBenchでは，Type1，Type2のコードクローンは，ソースコードの正規化後テキストの一致を確認することで判定している．
一方，Type3及びType4のコードクローンは，行単位での構文的類似度に基づいて0以上1未満の範囲で，次のように分類される．
この構文的類似度は，行の一致する割合で求められる．

\begin{description}
    \item[Strongly-Type3] 0.7以上1.0未満
    \item[Moderately-Type3] 0.5以上0.7未満
    \item[Weakly-Type3] 0.0以上0.5未満
\end{description}

コードクローン検出ツールの研究において，Weakly-Type3クローンはType4クローンとして用いられている~\cite{AlamICSME2025,Li2025,LiICSME2017,PinkuICSME2024,WangICSE2023,YuICSE2025,ZhangICCQ2024}．
また，機械学習を用いたコードクローン検出手法において，BigCloneBenchは学習データとして用いられている\cite{Li2025,LiICSME2017,WangICSE2023,YuICSE2025,ZhangICSE2019}．
しかし，BigCloneBenchは分類が不正確で，Type4コードクローンとして扱うには不適切であることが指摘されている~\cite{KrinkeIWSC2022,Krinke2025}. 
BigCloneBenchをType-4クローンの検出性能評価に用いる場合，誤った分類の影響で評価の妥当性が脅されるため，
Type-4クローンの検出を目標とする，機械学習を用いたコードクローン検出の評価結果に対する信頼性が低下する．


% 検証用(評価用)データとして用いてる~\cite{ZhangICCQ2024},~\cite{AlamICSME2025},~\cite{PinkuICSME2024}
% 学習データとして用いてる~\cite{WangICSE2023},~\cite{YuICSE2025}
% harmfl~\cite{KrinkeIWSC2022}

\subsection{抽象構文木(AST)}
ASTとはソースコードの構文構造を木構造で表現したデータ構造である．
図~\ref{fig:AST_discription}にJavaで書かれたソースコード例とそれに対応するASTを示す．
ASTにおいて，各頂点(ノード)はプログラムを構成する構文要素を表し，各辺はそれら要素間の論理的な親子関係や入れ子構造を表す．
図~\ref{fig:AST_discription}の例では，method\_declarationノードに，五つの子ノードが存在する(modifiers, integral\_type, identifier, formal\_parameters, block)．
これら五つのノードは，method\_declarationノードを親として持つ．
この親子関係に基づき，ASTは階層的な構造を持つ．

以下にASTに関する用語を示す．

\begin{description}
    \item[根ノード] 親を持たないノードを指す~\cite{Fan2021ICSE}．図~\ref{fig:AST_discription}では赤く示されたmethod\_declarationノードである．
    \item[葉ノード] 子を持たないノードを指す~\cite{Fan2021ICSE}．図~\ref{fig:AST_discription}では緑で示されたノードである．斜体で示されているのがそのノードの持つ値である．
\end{description}

\begin{figure}[t]
  \centering
  \includegraphics[width=0.8\textwidth]{images/ast_description.pdf}
  \caption{ソースコード例と対応するAST}
  \label{fig:AST_discription}
\end{figure}

本研究では，AST解析ライブラリとしてTree-sitter~\footnote{https://github.com/tree-sitter/tree-sitter}を用いた．
% Tree-sitterは多くのプログラミング言語に対応していることから選択した．
既存のJava解析研究ではEclipse JDT\footnote{https://github.com/eclipse-jdt/eclipse.jdt.core}
が広く利用されている~\cite{Falleri2014,TsantalisICSE2018}.
しかし，JDTはJava言語に強く依存しており，解析コストも大きい．
これに対し，Tree-sitterは多言語共通のインターフェースを提供しており，将来的な他言語への拡張性が高いことから選択した．

\section{本研究の動機}
% 前回と今回の原稿を見てずっと思っているんですが，研究の動機付けを重視していない気がする．
% なぜ独立したラベリングが必要なのが原稿にちゃんと書かれていない．
% スライドを作ったんでこれを参考にして，「本研究の動機」という独立した章を作ってもらえますか．
% そこでこのスライドの内容を自分なりにかみ砕いて記述してください．
% このスライドの通りにしなくて自分が書きやすいストーリーでいいので背景をちゃんと説明してください．
% もちろん図を使って．どんなに長くなってもいいのでちゃんとした説明を入れてください

ソースコードに含まれるコードクローンを検出するため，現在では様々なコードクローン検出ツールが存在する．
現状では，それらのツールは様々なソースコードに対して単一で用いられコードクローンの検出を行っている(図~\ref{fig:motivation_1})．
各コードクローン検出ツールは，異なるアルゴリズムを利用してコードクローン検出を行う．
例えば，CCFinder~\cite{KamiyaTSE2002}，NIL~\cite{NIL}は字句単位，Nicad~\cite{Nicad}は行単位で解析を行う検出ツールである．
単一のコードクローン検出ツールを用いた検出では，偏りがあり，対象ソースコード中に存在する全てのコードクローンを全て検出できるわけではない．

\begin{figure}[t]
  \centering
  \includegraphics[width=0.5\textwidth]{images/motivation_fig1.pdf}
  \caption{コードクローン検出の現状}
  \label{fig:motivation_1}
\end{figure}

検出されるコードクローンの偏りを軽減するため，複数の検出ツールを対象ソースコードに実行することが考えられる(図~\ref{fig:motivation_2})．
複数のツールを実行することで可能な限り多様なコードクローンの検出を試みることが考えられる．
しかし，各ツールにおけるコードクローン分類の基準が異なるため，検出後にどのTypeに分類されるかのラベリング結果が統一されない問題が起こる．
例えば，ある関数Aとある関数Bがツール1によってType3として検出された場合に，別のツール2では，Type4として検出される場合がある．
また，コードクローンの大規模データベース作成の際にも，この問題が発生する．
ツールごとにラベリング結果が異なるため，データの統合ができない．
さらには，コードクローンの検出は行うものの，ラベリングを行わないツールも存在する．
そのため，複数のクローン検出結果をそのラベリングも含めて単一のデータセットとして扱うことはできない．

\begin{figure}[t]
  \centering
  \includegraphics[width=0.8\textwidth]{images/motivation_fig2.pdf}
  \caption{コードクローン検出の問題}
  \label{fig:motivation_2}
\end{figure}

この問題を解決するため，提案手法では，コードクローン検出の後処理としての統一的なラベリングを行う(図~\ref{fig:motivation_3})．
これにより，複数ツールから検出されたコードクローンに一貫した分類に基づいたラベリングを行うことができる．
統一的なラベリングを行うことで，それぞれのツールの検出結果を単一のデータセットに統合することが可能となる．
これにより，コードクローン情報の質が向上し，コードクローンデータを他の研究や開発に利用しやすくなる．
例えば，LLMの学習用データとしての利用が挙げられ，LLMベースの超高精度なクローン検出の実現が見込まれる．

\begin{figure}[t]
  \centering
  \includegraphics[width=1\textwidth]{images/motivation_fig3.pdf}
  \caption{提案手法による解決策}
  \label{fig:motivation_3}
\end{figure}

提案手法を用いて，ソースコード中のコードクローンの検出を行うわけでなく，
コードクローン検出後のラベリングを行ったのは，実行時間の問題からである．
対象関数の数を$n$とした場合，提案手法の実行回数は$n^2$となる．
提案手法では，抽象構文木を用いて分類を行っており，二つの木を比較すること自体が非常に重い処理である．
全ての関数のペアの比較して結果を得ることは時間的に現実的ではない．
また，提案手法は入力をクローンペアと想定しているため，一定以上の差異がある場合にType4として判定している．
そのため，提案手法はクローンペアではない関数のペアが与えられた場合にそれがクローンペアではないのか，もしくはType4クローンなのかが判定できない．
これらのことから，提案手法ではコードクローン検出後に限定した統一的なラベリングを行う．



\section{提案手法}
本章では，本研究で提案するコードクローン検出の後処理としての統一的なラベリング手法について述べる．
提案手法では，クローンペアを入力し，そのクローンペアがどのTypeに分類されるかのラベルを出力とする．
% 図~\ref{fig:sub_a}に示すように，従来のコードクローン分析では，特定のツールの検出結果をそのまま利用する．
% そのため，ツールによってラベルが異なる，あるいは，出力にラベルを含まれないという課題が発生する．
% これは，ツール間の比較や，機械学習への高精度な学習データの提供を困難にする．

% しかし，図~\ref{fig:sub_b}に示すように，コードクローン検出ツールによって，コードクローン検出ののち，
% 提案手法によって統一された基準基づいたラベリングを行うことで，ツールによらないラベルが得られ，ツール間の比較や機械学習への高精度な学習データの提供が可能となる．

% \begin{figure}[t]
%     \centering
%     % 上の図 (a)
%     \begin{subfigure}{\textwidth}
%         \centering
%         \includegraphics[width=0.6\textwidth]{images/flow_before.pdf}
%         \caption{従来の流れ}
%         \label{fig:sub_a}
%     \end{subfigure}
    
%     \vspace{1cm} % 図と図の間の垂直方向の隙間を調整
    
%     % 下の図 (b)
%     \begin{subfigure}{\textwidth}
%         \centering
%         \includegraphics[width=0.9\textwidth]{images/flow_after.pdf}
%         \caption{提案手法を用いた場合の流れ}
%         \label{fig:sub_b}
%     \end{subfigure}
    
%     \caption{従来の方法と提案手法を用いた場合の違い}
%     \label{fig:ast_comparison}
% \end{figure}



\subsection{分類基準}

\begin{figure}[!t]
  \centering
  \includegraphics[width=0.8\textwidth]{images/ast_type1.pdf}
  \caption{Type1の例}
  \label{fig:AST_type1}
\end{figure}

本研究ではASTに基づいて新たな分類基準を定義した．
定義は以下の通りである．
すでにコードクローンとして検出されたコードが対象で，
与えられたクローンペアをそれぞれASTに変換し，二つのASTの差に応じて分類を行う．

\begin{description}
    \item[Type1] ASTが完全一致するコードクローン
    \item[Type2] 葉ノードを除いてASTが一致するコードクローン
    \item[Type3] 葉ノードに加え，単文以下のノードを除いてASTが一致するコードクローン
    \item[Type4] 上記に分類されないコードクローン
\end{description}

Type1〜3の分類基準について詳細を述べる．


Type1では葉ノードの持つ値を含むAST全体が完全に一致する(図~\ref{fig:AST_type1})．
ASTの木の形状と，斜体で示された値が完全に同一である場合，Type1と判断される．

Type2では葉ノードを除いたASTが一致する．
% 本研究では，2.1節で示したコードクローン研究における標準的な定義に従い，演算子を構文構造の一部として扱うため，演算子を葉ノードから除いた．
% ASTにおける演算子の表現形式はパーサの実装仕様に強く依存する．
% 例えば，一部のパーサでは演算子が二項演算ノードの下位に独立した葉ノードとして定義されるが，
% 別のパーサではノード自体の属性値として保持される．
本手法において，演算子を葉ノードの抽象化対象から除外した理由は，プログラムの演算論理を厳密に区別するためである．
Type2のコードクローンは識別子やリテラルの置換を許容するが，演算子の変更はプログラムの挙動を根本的に変えるものである．
例えば，$a + b$ と $a \times b$ はASTの形状は同一であるが，演算子が他の葉ノードと同様に除かれ比較されると，これらは同一のType2クローンとして判定されてしまう．
% このように，論理的に異なる処理内容を持つペアを同一視する「過度な抽象化」は，クローン判定の信頼性を損なう恐れがある．
したがって，本手法では演算子を識別子名やリテラル値のような置換可能な要素ではなく，構文構造を決定付ける不変の要素として扱い葉ノードから除いた．
図~\ref{fig:AST_type2}に示した例では，赤く示した部分がソースコード上で異なる部分である．
葉ノードとして除かれるノードを灰色で，比較対象として残るノードを黒で示している．
黒く示されたノードを持つASTの形状が同一であるため，Type2と判断される．


\begin{figure}[!t]
  \centering
  \includegraphics[width=0.8\textwidth]{images/ast_type2.pdf}
  \caption{Type2の例}
  \label{fig:AST_type2}
\end{figure}


\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.8\textwidth]{images/ast_type3.pdf}
  \caption{Type3の例}
  \label{fig:AST_type3}
\end{figure}

Type3では単文以下のノードを除いたASTが一致する．
% 単文として定義するノードを表~\ref{tab:statement_nodes}示す．これらはTree-sitterで用いられるノードで定義される．これらのノードを親ノードとして持つノードもType3では除かれる．
Javaにおいて，単文として定義される文を表~\ref{tab:statement_java}に示す．
図~\ref{fig:AST_type3}に示した例では，葉ノードに加え，return\_statementノード，expression\_statementノードが単文にあたるため，
これらのノード以下のノードが除かれる．黒く示されたノードを持つASTの形状が同一であるため，Type3と判断される．

\begin{table}[!b]
\centering
\caption{Javaにおいて単文として定義される文の例}
\label{tab:statement_java}
\begin{tabular}{lp{10cm}} 
\hline
\textbf{単文} & \textbf{例} \\ \hline
\multirow{2}{*}{式文} & x = a + b; \\
 & System.out.println(s);\\
変数宣言文 & int count = 0; \\
return文 & return result; \\
throw文 & throw new IllegalArgumentException(); \\
break文 & break; \\
continue文 & continue; \\
yield文 & yield 100; \\
assert文 & assert list != null;  \\ \hline
\end{tabular}
\end{table}




\section{評価実験}
本章では，評価実験について述べる．
本実験は，BigCloneBenchが行単位での構文的類似度に基づいて分類した場合と．提案手法で分類した場合のどちらがより人間の感覚に近いのかを評価することを目的としている．
特に，分類の基準が明確でないType3, Type4のコードクローンを対象とする．

\subsection{実験対象データセット}

% \subsection{BigCloneBenchの分類結果}
実験対象データセットとしてBigCloneBenchを用いた．
提案手法を用いてBigCloneBench内のクローンペアの分類を行った結果を表~\ref{tab:BCB_type}に示す．

\begin{table}[!b]
\centering
\caption{提案手法によるBigCloneBenchの分類結果}
\label{tab:BCB_type}
\begin{tabular}{ccrrrrr}
\hline
 & & Type1 & Type2 & Strongly-Type3 & Moderately-Type3 & Weakly-Type3 \\ \hline
\multirow{4}{*}{提案手法} & Type1 & 48,116 & 0 & 0 & 0 & 0 \\
& Type2 & 0 & 4,234 & 3,637 & 12  & 1  \\
& Type3 & 0 & 0 & 7,984 & 13,302 & 46,973  \\
& Type4 & 0 & 0 & 10,345 & 74,992 & 8,403,230 \\ \hline
& 合計 & 48,116 & 4,234 & 21,966 & 88,306 & 8,450,204 \\ \hline
\end{tabular}
\end{table}

% BigCloneBenchのStrongly-Type3，Moderately-Type3，Weakly-Type3に分類されるクローンペアのうち，提案手法でType2と判断されたクローンペアの例をListing~\ref{code:type２}に示す．修飾子が異なるため，BigCloneBenchではModerately-Type3に分類されていた．


% \begin{lstlisting}[caption={Type2と判断されたクローンペアの例}, label={code:type２}]
% // --- id 4644121 ---
% protected void copy (Reader reader, OutputStream outputs) throws IOException {
%     IOUtils.copy (reader, outputs);
% }

% // --- id 11088627 ---
% public static void copyWithoutClose (InputStream is, OutputStream os) throws IOException {
%     IOUtils.copy (is, os);
%     }
% \end{lstlisting}


\subsection{実験手順}
被験者はコンピュータサイエンスを専攻する博士前期課程の大学院生6人であり，いずれもJavaを用いたプログラミングの経験がある．
以下のいずれかの基準を満たすクローンペアを本研究の調査対象とした．

\begin{itemize}
    \item Strongly-Type3に分類されるクローンペアのうち提案手法でType4と分類されたクローンペア
    \item Weakly-Type3に分類されるクローンペアのうち提案手法でType3と分類されたクローンペア
\end{itemize}

BigCloneBenchに含まれるクローンペアは，いずれもメソッド単位のコード片から構成される．
同一のメソッドが複数のペアに含まれる場合は，そのうち一組のみを抽出対象とした．
ペアを構成する二つのメソッドの合計トークン数が少ない順にそれぞれ50個，合計100個のクローンペアを対象とした．
被験者には，事前に，2.1節に記述したコードクローン分類の定義を提示し，100個のクローンペアがどちらに分類されるべきかを判断してもらった．
また，判断理由についても回答してもらった．

\section{実験結果と考察}

本章では評価実験の結果とそれに対する考察を述べる．

\subsection{実験結果}

結果を図に示す．
BigCloneBenchでStrongly-Type3に分類されるクローンペアのうち提案手法でType4と分類されたクローンペアは，
人間の感覚に反するという結果になった
一方，Weakly-Type3に分類されるクローンペアのうち提案手法でType3と分類されたクローンペアは，
人間の感覚に近いという結果になった．
また，全体的にType3と判断されたクローンペアの数が多かった．
それぞれについて，被験者による評価と乖離した場合，一致した場合，評価が分かれた場合についてコードを確認し，分析を行った．
以降に詳細を述べる．

\subsubsection{提案手法でType4}
提案手法の分類は人間の感覚に反するという結果になった．
被験者6人のうち，6人全員がType4と判断したクローンペアは存在せず，
最大で4人がType4と判断したクローンペアが50ペア中2ペア存在した．
一方，6人全員がType3と判断したクローンペアは3つ存在した．
そのうち2つについて例を示しながら詳細を述べる．


\begin{figure}[h]
    \centering
    % --- (a) のコード ---
    \begin{subfigure}{\textwidth}
        \centering
        % キャプションを下に配置
        \begin{lstlisting}[
        label={code:experimet_pair57},
        escapechar=|,  % エスケープ文字として | を指定
        basicstyle=\small\ttfamily,
        captionpos=b] 
private void writeFile (FileInputStream inFile, FileOutputStream outFile) throws IOException {
    byte [] buf = new byte [2048];
    int read;
    while (|\colorbox{highlightorange}{(read = inFile.read (buf)) > 0 \&\& ! stopped}|) outFile.write (buf, 0, read);

    inFile.close ();
}
        \end{lstlisting}
        \subcaption{Code 1の構成}
    \end{subfigure}

    \vspace{1.5em} % 上下のコードの間の隙間

    % --- (b) のコード ---
    \begin{subfigure}{\textwidth}
        \centering
        \begin{lstlisting}[
        label={code:experimet_pair57},
        escapechar=|,  % エスケープ文字として | を指定
        basicstyle=\small\ttfamily,
        captionpos=b] 
private void writeFile (FileInputStream inFile, FileOutputStream outFile) throws IOException {
    byte [] buf = new byte [2048];
    int read;
    while (|\colorbox{highlightorange}{(read = inFile.read (buf)) > 0}|) outFile.write (buf, 0, read);

    inFile.close ();
}
        \end{lstlisting}
        \subcaption{Code 2の構成}
    \end{subfigure}

    \caption{被験者全員がType3と判断したクローンペアの例}
    \label{code:experimet_pair34}
\end{figure}


Listing~\ref{code:experimet_pair34}は，黄色で示されたwhile文の条件式でASTに差異が生じ，提案手法ではType4と判断された．
被験者の判断基準によると，条件式のみが異なるため，Type3の定義の文の変更にあたるとしてType3と判断していた．
現在の実装では，while文，if文，for文等の条件式を内包する構文に対して，条件式が異なる場合は，ASTが異なると判定される．
実装の変更を行うことで，条件式内の変更を許容する判定にすることが考えられる．
これにより，より人間の感覚に近い分類ができると考える．


\begin{figure}[h]
    \centering
    % --- (a) のコード ---
    \begin{subfigure}{\textwidth}
        \centering
        % キャプションを下に配置
        \begin{lstlisting}[
        label={code:experimet_pair57},
        escapechar=|,  % エスケープ文字として | を指定
        basicstyle=\small\ttfamily,
        captionpos=b] 
public static final void copy (|\colorbox{highlightorange}{InputStream is, OutputStream os}|) throws IOException {
    try {
        IOUtils.copy (is, os);
    } finally {
        IOUtils.closeQuietly (is);
        IOUtils.closeQuietly (os);
    }
}
        \end{lstlisting}
        \subcaption{Code 1の構成}
    \end{subfigure}

    \vspace{1.5em} % 上下のコードの間の隙間

    % --- (b) のコード ---
    \begin{subfigure}{\textwidth}
        \centering
        \begin{lstlisting}[
        label={code:experimet_pair57},
        escapechar=|,  % エスケープ文字として | を指定
        basicstyle=\small\ttfamily,
        captionpos=b] 
public static void readFile (|\colorbox{highlightorange}{FOUserAgent ua, String uri, OutputStream output}|) throws IOException {
    InputStream in = getURLInputStream (ua, uri);
    try {
        IOUtils.copy (in, output);
    } finally {
        IOUtils.closeQuietly (in);
    }
}
        \end{lstlisting}
        \subcaption{Code 2の構成}
    \end{subfigure}

    \caption{被験者全員がType3と判断したクローンペアの例}
    \label{code:experimet_pair57}
\end{figure}


Listing~\ref{code:experimet_pair57}は，与えられた引数によってASTに差異が生じ，提案手法ではType4と判断された．


\begin{figure}[h]
    \centering
    % --- (a) のコード ---
    \begin{subfigure}{\textwidth}
        \centering
        % キャプションを下に配置
        \begin{lstlisting}[
        label={code:experimet_pair57},
        escapechar=|,  % エスケープ文字として | を指定
        basicstyle=\small\ttfamily,
        captionpos=b] 
public static synchronized void shuffle (int [] anArray) {
    int n = anArray.length;
    for (int i = n - 1;
    i >= 1; i --) {
        int j = randomSource.nextInt (i + 1);
        int temp = anArray [j];
        anArray [j] = anArray [i];
        anArray [i] = temp;
    }
}
        \end{lstlisting}
        \subcaption{Code 1の構成}
    \end{subfigure}

    \vspace{1.5em} % 上下のコードの間の隙間

    % --- (b) のコード ---
    \begin{subfigure}{\textwidth}
        \centering
        \begin{lstlisting}[
        label={code:experimet_pair57},
        escapechar=|,  % エスケープ文字として | を指定
        basicstyle=\small\ttfamily,
        captionpos=b] 
public static synchronized void shuffle (int [] anArray) {
    int n = anArray.length;
    for (int i = n - 1;
    i >= 1; i --) {
        int j = randomSource.nextInt (i + 1);
        int temp = anArray [j];
        anArray [j] = anArray [i];
        anArray [i] = temp;
    }
}
        \end{lstlisting}
        \subcaption{Code 2の構成}
    \end{subfigure}

    \caption{被験者六人中二人がType4と判断したクローンペアの例}
    \label{code:experimet_pair56}
\end{figure}


\subsubsection{提案手法でType3}

\begin{figure}[h]
    \centering
    % --- (a) のコード ---
    \begin{subfigure}{\textwidth}
        \centering
        % キャプションを下に配置
        \begin{lstlisting}[
        label={code:experimet_pair57},
        escapechar=|,  % エスケープ文字として | を指定
        basicstyle=\small\ttfamily,
        captionpos=b] 
public String hash (String s) throws NoSuchAlgorithmException {
    MessageDigest md;
    md = MessageDigest.getInstance ("SHA-1");
    md.update (s.getBytes ());
    return Hex.toHex (md.digest ());
}
        \end{lstlisting}
        \subcaption{Code 1の構成}
    \end{subfigure}

    \vspace{1.5em} % 上下のコードの間の隙間

    % --- (b) のコード ---
    \begin{subfigure}{\textwidth}
        \centering
        \begin{lstlisting}[
        label={code:experimet_pair57},
        escapechar=|,  % エスケープ文字として | を指定
        basicstyle=\small\ttfamily,
        captionpos=b] 
public static String encryptSHA (String pwd) throws NoSuchAlgorithmException {
    MessageDigest d = java.security.MessageDigest.getInstance ("SHA-1");
    d.reset ();
    d.update (pwd.getBytes ());
    BASE64Encoder encoder = new BASE64Encoder ();
    return encoder.encode (d.digest ());
}
        \end{lstlisting}
        \subcaption{Code 2の構成}
    \end{subfigure}

    \caption{意見が割れたクローンペアの例}
    \label{code:experimet_pair36}
\end{figure}

\subsubsection{被験者ごとの傾向}
被験者6人の回答について，判断基準から二分されると考える．
それは，判断の際，注目する箇所が構文構造であるか，同一の機能をもつかという点である．
前者は，2.1節のType3の定義に基づき，クローンペアで異なる部分が，文の挿入，削除，変更による違いである場合にType3，
そうでない場合にType4と判断していた．
一方，後者は，2.1節のType4の定義に基づき，同一の処理を行う場合にType4，行わない場合にType3と判断していた．
この基準の違いが，判定に影響を与えたと考えられる．
図~\ref{code:experimet_pair36}では，前者はType3と，後者はType4と判断していた．
このように，判断が割れる原因になる．

\section{妥当性への脅威}

% \subsection{内部妥当性}
% 本研究では，Tree-sitterを用いてASTを作成し，Tree-sitterの定めるノードを基準とし分類を行った．
% したがって，Tree-sitterの性能に依存する．

% \subsection{外部妥当性}
% 本研究では，Java言語を対象にコードクローンの分類を行った．
% PythonやC言語で同様の結果が得られるとは限らない．

% 本研究ではデータセットとしてBigCloneBenchを用いた．
% この結果はBigClonBenchに含まれるメソッドに依存する可能性がある．

% 本研究の評価実験に用いたクローンペアは，二つのクローンペアのトークン数の合計が少ないものから選択している．
% したがって，長いメソッドや複雑なコードに対する結果が異なる可能性がある．

\subsection{内部妥当性}
内部妥当性への脅威としては，提案手法の実装および解析基盤として採用したTree-sitterの精度が挙げられる．
パーサによる構文解析に誤りが含まれる場合，正しくラベリングが行われない可能性がある．
これに対し，本研究では解析対象の各文に対し，生成されたASTノードが意図した構文要素と一致しているかを事前にテストを用いて検証し，
実装の正確性を確認している．
% また，実験における手動評価の主観性も脅威となり得るが，これは事前に定義したコードクローンの分類基準に基づき，
% 一貫性を保つよう細心の注意を払って判定を行った．

\subsection{外部妥当性}
外部妥当性への脅威は，結果の汎用性に関するものである．
本研究では評価対象を Java 言語に限定しており，他のプログラミング言語（Python や C++ 等）における有効性は未検証である．
しかし，採用した Tree-sitter は多言語対応の解析基盤であり，
% 本手法の基本アルゴリズムは言語に依存しない設計となっているため，
他言語への拡張は比較的容易であると考えられる．
また，サンプリングにおいてトークン数の合計が少ないペアを優先的に抽出したため，大規模なメソッドにおける精度については更なる検証が必要である．

% \subsection{構成妥当性}
% 構成妥当性への脅威は，コードクローンの分類の定義と測定方法の乖離である．
% 特に，演算子を抽象化の対象から除外した判断は，既存のツールや先行研究のType2の定義と一部異なる可能性がある．
% しかし，3章で述べた通り，演算子はプログラムの計算論理の核心をなす要素であり，
% かつ AST の実装依存性を排除するためには固定的な要素として扱うことが妥当であると判断した．
% この設計方針がラベリング結果に与える影響については，実験結果の考察において詳細に検討している．

% \subsection{結論妥当性}
% 結論妥当性への脅威としては，評価に使用したクローンペアのサンプルサイズ（合計100個）が挙げられる．
% 統計的な有意性を完全に確保するには十分な数とは言えないが，本研究の主目的は提案する統一的ラベリング手法の原理的な有効性と実現可能性を示すことにあり，
% 初期評価としては適切な規模であると考える．
% 今後，より大規模かつ多様なデータセットを用いた検証が課題である．

\section{おわりに}

本研究では，コードクローン検出の後処理としての統一的ラベリング手法の提案を行なった．


今後の展望として，次の二つが考えられる．
一つ目は，提案手法を用いて統一的なラベリングが行われたデータセットの作成である．
% 複数のコードクローン検出ツールを用いてコードクローンを検出し，提案手法でラベリングを行うことで，大規模なコードクローンのデータセットの作成が見込まれる．
% 作成した，データセットをLLMの学習に用いて，実際に性能向上につながるか調査を行うことが考えられる．
複数の既存検出ツールから得られた結果に対し，本手法を用いて統一的なラベリングを行うことで，
ノイズの少ない高品質なデータセットの整備が可能となる．
このようなデータセットをLLMの学習データとして活用し，
クローン情報の付与がLLMのコード生成精度や理解能力の向上にどの程度寄与するかを詳細に検証することが考えられる．

% 二つ目は，多言語への提案手法の拡張である．
% Tree-sitterは多言語共通のインターフェースを提供しており，本研究で利用したJava言語以外への拡張が容易である．
% したがって，他言語への拡張と，本研究と同様の結果が得られるか，評価実験を行うことが考えられる．
二つ目は，Java以外のプログラミング言語への提案手法の拡張である．
本研究で採用した解析ライブラリであるTree-sitterは多言語共通のインターフェースを提供しており，
PythonやC++といった他言語への適用が容易であるという特長を持つ．
したがって，今後は対象言語を拡大し，異なる言語仕様においても本研究と同様のラベリング精度および一貫性が得られるかについて，
評価実験を通じて手法の汎用性を実証していく必要がある．

% 参考文献を参照する\cite{KamiyaTSE2002}

\acknowledgement{
}

% 参考文献を出力
\bibliographystyle{jplain}
\bibliography{reference}

% \section{付録}
% \begin{table}[hb]
% \centering
% \caption{Tree-sitterにおいて単文として定義するノードと役割}
% \label{tab:statement_nodes}
% \begin{tabular}{lp{10cm}} 
% \hline
% \textbf{ノード} & \textbf{説明} \\ \hline
% expression\_statement & 式(代入，メソッド呼び出し，インクリメント等)を文として完結させたノード \\
% local\_variable\_declaration & メソッド内でローカル変数を宣言する文, 型と識別子を保持するノード\\
% declaration & クラス，インタフェース，またはフィールド等の宣言全般を指す広義のノード \\
% return\_statement & メソッドの実行を終了し，呼び出し元へ値を返す制御文 \\
% throw\_statement & 例外を明示的にスローし，通常の実行フローを中断する文 \\
% break\_statement & ループ(for, while等)やswitchブロックから直ちに脱出するための制御文 \\
% continue\_statement & ループの現在の反復を終了し，次の反復処理へスキップするための文 \\
% yield\_statement & switch式において，値を返してブロックを終了するための文(Java 13以降) \\
% assert\_statement & プログラムの前提条件を検証するための表明文. デバッグや検証に用いられる.  \\ \hline
% \end{tabular}
% \end{table}

\end{document}
